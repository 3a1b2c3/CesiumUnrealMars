/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_three__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-loader-3dtiles */ \"./node_modules/three-loader-3dtiles/dist/three-loader-3dtiles.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\n * 3D Tiles component for A-Frame.\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    }\n  },\n  init: async function () {\n    this.camera = this.data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    this.el.setObject3D('tileset', model);\n    this.originalCamera = this.camera;\n    this.el.sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = this.el.sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        this.el.sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = this.el.sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    this.el.sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (this.data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    }\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.el.sceneEl.renderer, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        dracoDecoderPath: 'https://unpkg.com/three@0.133.0/examples/js/libs/draco',\n        basisTranscoderPath: 'https://unpkg.com/three@0.133.0/examples/js/libs/basis',\n        cesiumIONToken: this.data.cesiumIONToken,\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        pointCloudColoring: pointCloudColoring,\n        updateTransforms: true\n      }\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\n * Textarea component for A-Frame.\n *\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ }),

/***/ "./node_modules/three-loader-3dtiles/dist/three-loader-3dtiles.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/three-loader-3dtiles/dist/three-loader-3dtiles.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ Loader3DTiles),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ PointCloudColoring),\n/* harmony export */   \"Shading\": () => (/* binding */ Shading)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction assert$7(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n\nconst isBrowser$2 = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\nconst matches$1 = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nmatches$1 && parseFloat(matches$1[1]) || 0;\n\nconst VERSION$8 = \"3.1.4\" ;\n\nfunction assert$6(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n\nconst globals$1 = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\nconst global_ = globals$1.global || globals$1.self || globals$1.window || {};\nconst isBrowser$1 = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\nconst isWorker = typeof importScripts === 'function';\nconst isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nmatches && parseFloat(matches[1]) || 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass WorkerJob {\n  constructor(jobName, workerThread) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"workerThread\", void 0);\n\n    _defineProperty(this, \"isRunning\", void 0);\n\n    _defineProperty(this, \"result\", void 0);\n\n    _defineProperty(this, \"_resolve\", void 0);\n\n    _defineProperty(this, \"_reject\", void 0);\n\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.isRunning = true;\n\n    this._resolve = () => {};\n\n    this._reject = () => {};\n\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  postMessage(type, payload) {\n    this.workerThread.postMessage({\n      source: 'loaders.gl',\n      type,\n      payload\n    });\n  }\n\n  done(value) {\n    assert$6(this.isRunning);\n    this.isRunning = false;\n\n    this._resolve(value);\n  }\n\n  error(error) {\n    assert$6(this.isRunning);\n    this.isRunning = false;\n\n    this._reject(error);\n  }\n\n}\n\nconst workerURLCache = new Map();\nfunction getLoadableWorkerURL(props) {\n  assert$6(props.source && !props.url || !props.source && props.url);\n  let workerURL = workerURLCache.get(props.source || props.url);\n\n  if (!workerURL) {\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert$6(workerURL);\n  return workerURL;\n}\n\nfunction getLoadableWorkerURLFromURL(url) {\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\nfunction getLoadableWorkerURLFromSource(workerSource) {\n  const blob = new Blob([workerSource], {\n    type: 'application/javascript'\n  });\n  return URL.createObjectURL(blob);\n}\n\nfunction buildScriptSource(workerUrl) {\n  return \"try {\\n  importScripts('\".concat(workerUrl, \"');\\n} catch (error) {\\n  console.error(error);\\n  throw error;\\n}\");\n}\n\nfunction getTransferList(object, recursive = true, transfers) {\n  const transfersSet = transfers || new Set();\n\n  if (!object) ; else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) ; else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n\n  return false;\n}\n\nconst NOOP = () => {};\n\nclass WorkerThread {\n  static isSupported() {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor(props) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"source\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"terminated\", false);\n\n    _defineProperty(this, \"worker\", void 0);\n\n    _defineProperty(this, \"onMessage\", void 0);\n\n    _defineProperty(this, \"onError\", void 0);\n\n    _defineProperty(this, \"_loadableURL\", '');\n\n    const {\n      name,\n      source,\n      url\n    } = props;\n    assert$6(source || url);\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n\n    this.onError = error => console.log(error);\n\n    this.worker = this._createBrowserWorker();\n  }\n\n  destroy() {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    this.worker.terminate();\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  postMessage(data, transferList) {\n    transferList = transferList || getTransferList(data);\n    this.worker.postMessage(data, transferList);\n  }\n\n  _getErrorFromErrorEvent(event) {\n    let message = 'Failed to load ';\n    message += \"worker \".concat(this.name, \" from \").concat(this.url, \". \");\n\n    if (event.message) {\n      message += \"\".concat(event.message, \" in \");\n    }\n\n    if (event.lineno) {\n      message += \":\".concat(event.lineno, \":\").concat(event.colno);\n    }\n\n    return new Error(message);\n  }\n\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({\n      source: this.source,\n      url: this.url\n    });\n    const worker = new Worker(this._loadableURL, {\n      name: this.name\n    });\n\n    worker.onmessage = event => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n\n    worker.onerror = error => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n\n    worker.onmessageerror = event => console.error(event);\n\n    return worker;\n  }\n\n}\n\nclass WorkerPool {\n  constructor(props) {\n    _defineProperty(this, \"name\", 'unnamed');\n\n    _defineProperty(this, \"source\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"maxConcurrency\", 1);\n\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n\n    _defineProperty(this, \"onDebug\", () => {});\n\n    _defineProperty(this, \"reuseWorkers\", true);\n\n    _defineProperty(this, \"props\", {});\n\n    _defineProperty(this, \"jobQueue\", []);\n\n    _defineProperty(this, \"idleQueue\", []);\n\n    _defineProperty(this, \"count\", 0);\n\n    _defineProperty(this, \"isDestroyed\", false);\n\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props) {\n    this.props = { ...this.props,\n      ...props\n    };\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {\n    const startPromise = new Promise(onStart => {\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n\n    this._startQueuedJob();\n\n    return await startPromise;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n\n    if (!workerThread) {\n      return;\n    }\n\n    const queuedJob = this.jobQueue.shift();\n\n    if (queuedJob) {\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n\n      workerThread.onError = error => queuedJob.onError(job, error);\n\n      queuedJob.onStart(job);\n\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n\n}\n\nconst DEFAULT_PROPS$3 = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  onDebug: () => {},\n  reuseWorkers: true\n};\nclass WorkerFarm {\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n\n  static getWorkerFarm(props = {}) {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n\n    WorkerFarm._workerFarm.setProps(props);\n\n    return WorkerFarm._workerFarm;\n  }\n\n  constructor(props) {\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"workerPools\", new Map());\n\n    this.props = { ...DEFAULT_PROPS$3\n    };\n    this.setProps(props);\n    this.workerPools = new Map();\n  }\n\n  destroy() {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n  }\n\n  setProps(props) {\n    this.props = { ...this.props,\n      ...props\n    };\n\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  getWorkerPool(options) {\n    const {\n      name,\n      source,\n      url\n    } = options;\n    let workerPool = this.workerPools.get(name);\n\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n\n}\n\n_defineProperty(WorkerFarm, \"_workerFarm\", void 0);\n\nconst NPM_TAG = 'latest';\nfunction getWorkerURL(worker, options = {}) {\n  const workerOptions = options[worker.id] || {};\n  const workerFile = \"\".concat(worker.id, \"-worker.js\");\n  let url = workerOptions.workerUrl;\n\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  if (options._workerType === 'test') {\n    url = \"modules/\".concat(worker.module, \"/dist/\").concat(workerFile);\n  }\n\n  if (!url) {\n    let version = worker.version;\n\n    if (version === 'latest') {\n      version = NPM_TAG;\n    }\n\n    const versionTag = version ? \"@\".concat(version) : '';\n    url = \"https://unpkg.com/@loaders.gl/\".concat(worker.module).concat(versionTag, \"/dist/\").concat(workerFile);\n  }\n\n  assert$6(url);\n  return url;\n}\n\nfunction validateWorkerVersion(worker, coreVersion = VERSION$8) {\n  assert$6(worker, 'no worker provided');\n  const workerVersion = worker.version;\n\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  return true;\n}\n\nvar ChildProcessProxy = {};\n\nvar node = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), ChildProcessProxy, {\n    'default': ChildProcessProxy\n}));\n\nconst VERSION$7 = \"3.1.4\" ;\nconst loadLibraryPromises = {};\nasync function loadLibrary(libraryUrl, moduleName = null, options = {}) {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\nfunction getLibraryUrl(library, moduleName, options) {\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  const modules = options.modules || {};\n\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  if (!isBrowser$1) {\n    return \"modules/\".concat(moduleName, \"/dist/libs/\").concat(library);\n  }\n\n  if (options.CDN) {\n    assert$6(options.CDN.startsWith('http'));\n    return \"\".concat(options.CDN, \"/\").concat(moduleName, \"@\").concat(VERSION$7, \"/dist/libs/\").concat(library);\n  }\n\n  if (isWorker) {\n    return \"../src/libs/\".concat(library);\n  }\n\n  return \"modules/\".concat(moduleName, \"/src/libs/\").concat(library);\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser$1) {\n    try {\n      return node && ChildProcessProxy.requireFromFile && (await ChildProcessProxy.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser$1) {\n    return ChildProcessProxy.requireFromString && ChildProcessProxy.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    eval.call(global_, scriptSource);\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n\n  document.body.appendChild(script);\n  return null;\n}\n\nfunction canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\nasync function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n  const name = loader.id;\n  const url = getWorkerURL(loader, options);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({\n    name,\n    url\n  });\n  options = JSON.parse(JSON.stringify(options));\n  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));\n  job.postMessage('process', {\n    input: data,\n    options\n  });\n  const result = await job.result;\n  return await result.result;\n}\n\nasync function onMessage(parseOnMainThread, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      const {\n        id,\n        input,\n        options\n      } = payload;\n\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n\n      break;\n\n    default:\n      console.warn(\"parse-with-worker unknown message \".concat(type));\n  }\n}\n\nfunction getFirstCharacters$1(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString$3(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString$3(data, byteOffset, length);\n  }\n\n  return '';\n}\nfunction getMagicString$3(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}\n\nfunction parseJSON(string) {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(\"Failed to parse JSON from data starting with \\\"\".concat(getFirstCharacters$1(string), \"\\\"\"));\n  }\n}\n\nfunction isBuffer$1(value) {\n  return value && typeof value === 'object' && value.isBuffer;\n}\nfunction bufferToArrayBuffer(buffer) {\n  if (isBuffer$1(buffer)) {\n    const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);\n    return typedArray.slice().buffer;\n  }\n\n  return buffer;\n}\n\nfunction toArrayBuffer(data) {\n  if (isBuffer$1(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\nfunction compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction concatenateArrayBuffers(...sources) {\n  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n  const result = new Uint8Array(byteLength);\n  let offset = 0;\n\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  return result.buffer;\n}\nfunction sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n\nfunction padToNBytes(byteLength, padding) {\n  assert$7(byteLength >= 0);\n  assert$7(padding > 0);\n  return byteLength + (padding - 1) & ~(padding - 1);\n}\nfunction copyToArray(source, target, targetOffset) {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  target.set(sourceArray, targetOffset);\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n\nasync function concatenateArrayBuffersAsync(asyncIterator) {\n  const arrayBuffers = [];\n\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nfunction getHiResTimestamp$1() {\n  let timestamp;\n\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nclass Stat {\n  constructor(name, type) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"sampleSize\", 1);\n\n    _defineProperty(this, \"time\", void 0);\n\n    _defineProperty(this, \"count\", void 0);\n\n    _defineProperty(this, \"samples\", void 0);\n\n    _defineProperty(this, \"lastTiming\", void 0);\n\n    _defineProperty(this, \"lastSampleTime\", void 0);\n\n    _defineProperty(this, \"lastSampleCount\", void 0);\n\n    _defineProperty(this, \"_count\", 0);\n\n    _defineProperty(this, \"_time\", 0);\n\n    _defineProperty(this, \"_samples\", 0);\n\n    _defineProperty(this, \"_startTime\", 0);\n\n    _defineProperty(this, \"_timerPending\", false);\n\n    this.name = name;\n    this.type = type;\n    this.reset();\n  }\n\n  setSampleSize(samples) {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  incrementCount() {\n    this.addCount(1);\n    return this;\n  }\n\n  decrementCount() {\n    this.subtractCount(1);\n    return this;\n  }\n\n  addCount(value) {\n    this._count += value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  subtractCount(value) {\n    this._count -= value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  addTime(time) {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  timeStart() {\n    this._startTime = getHiResTimestamp$1();\n    this._timerPending = true;\n    return this;\n  }\n\n  timeEnd() {\n    if (!this._timerPending) {\n      return this;\n    }\n\n    this.addTime(getHiResTimestamp$1() - this._startTime);\n    this._timerPending = false;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset() {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n    return this;\n  }\n\n  _checkSampling() {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n\n}\n\nclass Stats {\n  constructor(options) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"stats\", {});\n\n    this.id = options.id;\n    this.stats = {};\n\n    this._initializeStats(options.stats);\n\n    Object.seal(this);\n  }\n\n  get(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';\n    return this._getOrCreate({\n      name,\n      type\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn) {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable() {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n    return table;\n  }\n\n  _initializeStats() {\n    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat) {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {\n      name,\n      type\n    } = stat;\n\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n\n    return this.stats[name];\n  }\n\n}\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\nconst DEFAULT_PROPS$2 = {\n  id: 'request-scheduler',\n  throttleRequests: true,\n  maxRequests: 6\n};\nclass RequestScheduler {\n  constructor(props = {}) {\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"activeRequestCount\", 0);\n\n    _defineProperty(this, \"requestQueue\", []);\n\n    _defineProperty(this, \"requestMap\", new Map());\n\n    _defineProperty(this, \"deferredUpdate\", null);\n\n    this.props = { ...DEFAULT_PROPS$2,\n      ...props\n    };\n    this.stats = new Stats({\n      id: this.props.id\n    });\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  scheduleRequest(handle, getPriority = () => 0) {\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({\n        done: () => {}\n      });\n    }\n\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle);\n    }\n\n    const request = {\n      handle,\n      priority: 0,\n      getPriority\n    };\n    const promise = new Promise(resolve => {\n      request.resolve = resolve;\n      return request;\n    });\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n\n    this._issueNewRequests();\n\n    return promise;\n  }\n\n  _issueRequest(request) {\n    const {\n      handle,\n      resolve\n    } = request;\n    let isDone = false;\n\n    const done = () => {\n      if (!isDone) {\n        isDone = true;\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n\n        this._issueNewRequests();\n      }\n    };\n\n    this.activeRequestCount++;\n    return resolve ? resolve({\n      done\n    }) : Promise.resolve({\n      done\n    });\n  }\n\n  _issueNewRequests() {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  _issueNewRequestsAsync() {\n    this.deferredUpdate = null;\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n\n      if (request) {\n        this._issueRequest(request);\n      }\n    }\n  }\n\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n\n      if (!this._updateRequest(request)) {\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle);\n\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nlet pathPrefix = '';\nconst fileAliases = {};\nfunction resolvePath(filename) {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = \"\".concat(pathPrefix).concat(filename);\n  }\n\n  return filename;\n}\n\nfunction filename(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';\n}\nfunction dirname(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n\nconst isBoolean = x => typeof x === 'boolean';\n\nconst isFunction = x => typeof x === 'function';\n\nconst isObject = x => x !== null && typeof x === 'object';\nconst isPureObject = x => isObject(x) && x.constructor === {}.constructor;\nconst isIterable = x => x && typeof x[Symbol.iterator] === 'function';\nconst isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';\nconst isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;\nconst isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;\nconst isBuffer = x => x && typeof x === 'object' && x.isBuffer;\nconst isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);\nconst isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nconst isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);\n\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\nfunction parseMIMEType(mimeString) {\n  const matches = MIME_TYPE_PATTERN.exec(mimeString);\n\n  if (matches) {\n    return matches[1];\n  }\n\n  return mimeString;\n}\nfunction parseMIMETypeFromURL(url) {\n  const matches = DATA_URL_PATTERN.exec(url);\n\n  if (matches) {\n    return matches[1];\n  }\n\n  return '';\n}\n\nconst QUERY_STRING_PATTERN = /\\?.*/;\nfunction getResourceUrlAndType(resource) {\n  if (isResponse(resource)) {\n    const url = stripQueryString(resource.url || '');\n    const contentTypeHeader = resource.headers.get('content-type') || '';\n    return {\n      url,\n      type: parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(url)\n    };\n  }\n\n  if (isBlob(resource)) {\n    return {\n      url: stripQueryString(resource.name || ''),\n      type: resource.type || ''\n    };\n  }\n\n  if (typeof resource === 'string') {\n    return {\n      url: stripQueryString(resource),\n      type: parseMIMETypeFromURL(resource)\n    };\n  }\n\n  return {\n    url: '',\n    type: ''\n  };\n}\nfunction getResourceContentLength(resource) {\n  if (isResponse(resource)) {\n    return resource.headers['content-length'] || -1;\n  }\n\n  if (isBlob(resource)) {\n    return resource.size;\n  }\n\n  if (typeof resource === 'string') {\n    return resource.length;\n  }\n\n  if (resource instanceof ArrayBuffer) {\n    return resource.byteLength;\n  }\n\n  if (ArrayBuffer.isView(resource)) {\n    return resource.byteLength;\n  }\n\n  return -1;\n}\n\nfunction stripQueryString(url) {\n  return url.replace(QUERY_STRING_PATTERN, '');\n}\n\nasync function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(resource);\n\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  const initialDataUrl = await getInitialDataUrl(resource);\n\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  if (typeof resource === 'string') {\n    resource = new TextEncoder().encode(resource);\n  }\n\n  const response = new Response(resource, {\n    headers\n  });\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\nasync function checkResponse(response) {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\nasync function getResponseError(response) {\n  let message = \"Failed to fetch resource \".concat(response.url, \" (\").concat(response.status, \"): \");\n\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n\n    if (contentType.includes('application/json')) {\n      text += \" \".concat(await response.text());\n    }\n\n    message += text;\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n  } catch (error) {}\n\n  return message;\n}\n\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n\n  if (typeof resource === 'string') {\n    return \"data:,\".concat(resource.slice(0, INITIAL_DATA_LENGTH));\n  }\n\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n\n      reader.onload = event => {\n        var _event$target;\n\n        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n      };\n\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return \"data:base64,\".concat(base64);\n  }\n\n  return null;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return btoa(binary);\n}\n\nasync function fetchFile(url, options) {\n  if (typeof url === 'string') {\n    url = resolvePath(url);\n    let fetchOptions = options;\n\n    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {\n      fetchOptions = options.fetch;\n    }\n\n    return await fetch(url, fetchOptions);\n  }\n\n  return await makeResponse(url);\n}\n\nfunction isElectron(mockUserAgent) {\n  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions.electron)) {\n    return true;\n  }\n\n  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;\n  const userAgent = mockUserAgent || realUserAgent;\n\n  if (userAgent && userAgent.indexOf('Electron') >= 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isBrowser() {\n  const isNode = typeof process === 'object' && String(process) === '[object process]' && !process.browser;\n  return !isNode || isElectron();\n}\n\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document,\n  process: typeof process === 'object' && process\n};\nconst window_ = globals.window || globals.self || globals.global;\nconst process_ = globals.process || {};\n\nconst VERSION$6 = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';\nisBrowser();\n\nfunction getStorage(type) {\n  try {\n    const storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return storage;\n  } catch (e) {\n    return null;\n  }\n}\n\nclass LocalStorage {\n  constructor(id) {\n    let defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';\n\n    _defineProperty(this, \"storage\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"config\", {});\n\n    this.storage = getStorage(type);\n    this.id = id;\n    this.config = {};\n    Object.assign(this.config, defaultSettings);\n\n    this._loadConfiguration();\n  }\n\n  getConfiguration() {\n    return this.config;\n  }\n\n  setConfiguration(configuration) {\n    this.config = {};\n    return this.updateConfiguration(configuration);\n  }\n\n  updateConfiguration(configuration) {\n    Object.assign(this.config, configuration);\n\n    if (this.storage) {\n      const serialized = JSON.stringify(this.config);\n      this.storage.setItem(this.id, serialized);\n    }\n\n    return this;\n  }\n\n  _loadConfiguration() {\n    let configuration = {};\n\n    if (this.storage) {\n      const serializedConfiguration = this.storage.getItem(this.id);\n      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};\n    }\n\n    Object.assign(this.config, configuration);\n    return this;\n  }\n\n}\n\nfunction formatTime(ms) {\n  let formatted;\n\n  if (ms < 10) {\n    formatted = \"\".concat(ms.toFixed(2), \"ms\");\n  } else if (ms < 100) {\n    formatted = \"\".concat(ms.toFixed(1), \"ms\");\n  } else if (ms < 1000) {\n    formatted = \"\".concat(ms.toFixed(0), \"ms\");\n  } else {\n    formatted = \"\".concat((ms / 1000).toFixed(2), \"s\");\n  }\n\n  return formatted;\n}\nfunction leftPad(string) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const padLength = Math.max(length - string.length, 0);\n  return \"\".concat(' '.repeat(padLength)).concat(string);\n}\n\nfunction formatImage(image, message, scale) {\n  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;\n  const imageUrl = image.src.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n\n  if (image.width > maxWidth) {\n    scale = Math.min(scale, maxWidth / image.width);\n  }\n\n  const width = image.width * scale;\n  const height = image.height * scale;\n  const style = ['font-size:1px;', \"padding:\".concat(Math.floor(height / 2), \"px \").concat(Math.floor(width / 2), \"px;\"), \"line-height:\".concat(height, \"px;\"), \"background:url(\".concat(imageUrl, \");\"), \"background-size:\".concat(width, \"px \").concat(height, \"px;\"), 'color:transparent;'].join('');\n  return [\"\".concat(message, \" %c+\"), style];\n}\n\nlet COLOR;\n\n(function (COLOR) {\n  COLOR[COLOR[\"BLACK\"] = 30] = \"BLACK\";\n  COLOR[COLOR[\"RED\"] = 31] = \"RED\";\n  COLOR[COLOR[\"GREEN\"] = 32] = \"GREEN\";\n  COLOR[COLOR[\"YELLOW\"] = 33] = \"YELLOW\";\n  COLOR[COLOR[\"BLUE\"] = 34] = \"BLUE\";\n  COLOR[COLOR[\"MAGENTA\"] = 35] = \"MAGENTA\";\n  COLOR[COLOR[\"CYAN\"] = 36] = \"CYAN\";\n  COLOR[COLOR[\"WHITE\"] = 37] = \"WHITE\";\n  COLOR[COLOR[\"BRIGHT_BLACK\"] = 90] = \"BRIGHT_BLACK\";\n  COLOR[COLOR[\"BRIGHT_RED\"] = 91] = \"BRIGHT_RED\";\n  COLOR[COLOR[\"BRIGHT_GREEN\"] = 92] = \"BRIGHT_GREEN\";\n  COLOR[COLOR[\"BRIGHT_YELLOW\"] = 93] = \"BRIGHT_YELLOW\";\n  COLOR[COLOR[\"BRIGHT_BLUE\"] = 94] = \"BRIGHT_BLUE\";\n  COLOR[COLOR[\"BRIGHT_MAGENTA\"] = 95] = \"BRIGHT_MAGENTA\";\n  COLOR[COLOR[\"BRIGHT_CYAN\"] = 96] = \"BRIGHT_CYAN\";\n  COLOR[COLOR[\"BRIGHT_WHITE\"] = 97] = \"BRIGHT_WHITE\";\n})(COLOR || (COLOR = {}));\n\nfunction getColor(color) {\n  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;\n}\n\nfunction addColor(string, color, background) {\n  if (!isBrowser && typeof string === 'string') {\n    if (color) {\n      color = getColor(color);\n      string = \"\\x1B[\".concat(color, \"m\").concat(string, \"\\x1B[39m\");\n    }\n\n    if (background) {\n      color = getColor(background);\n      string = \"\\x1B[\".concat(background + 10, \"m\").concat(string, \"\\x1B[49m\");\n    }\n  }\n\n  return string;\n}\n\nfunction autobind(obj) {\n  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];\n  const proto = Object.getPrototypeOf(obj);\n  const propNames = Object.getOwnPropertyNames(proto);\n\n  for (const key of propNames) {\n    if (typeof obj[key] === 'function') {\n      if (!predefined.find(name => key === name)) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  }\n}\n\nfunction assert$5(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nfunction getHiResTimestamp() {\n  let timestamp;\n\n  if (isBrowser && 'performance' in window_) {\n    var _window$performance, _window$performance$n;\n\n    timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);\n  } else if ('hrtime' in process_) {\n    var _process$hrtime;\n\n    const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nconst originalConsole = {\n  debug: isBrowser ? console.debug || console.log : console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\nconst DEFAULT_SETTINGS = {\n  enabled: true,\n  level: 0\n};\n\nfunction noop$1() {}\n\nconst cache = {};\nconst ONCE = {\n  once: true\n};\nclass Log {\n  constructor() {\n    let {\n      id\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      id: ''\n    };\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"VERSION\", VERSION$6);\n\n    _defineProperty(this, \"_startTs\", getHiResTimestamp());\n\n    _defineProperty(this, \"_deltaTs\", getHiResTimestamp());\n\n    _defineProperty(this, \"_storage\", void 0);\n\n    _defineProperty(this, \"userData\", {});\n\n    _defineProperty(this, \"LOG_THROTTLE_TIMEOUT\", 0);\n\n    this.id = id;\n    this._storage = new LocalStorage(\"__probe-\".concat(this.id, \"__\"), DEFAULT_SETTINGS);\n    this.userData = {};\n    this.timeStamp(\"\".concat(this.id, \" started\"));\n    autobind(this);\n    Object.seal(this);\n  }\n\n  set level(newLevel) {\n    this.setLevel(newLevel);\n  }\n\n  get level() {\n    return this.getLevel();\n  }\n\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n\n  getLevel() {\n    return this._storage.config.level;\n  }\n\n  getTotal() {\n    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));\n  }\n\n  getDelta() {\n    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));\n  }\n\n  set priority(newPriority) {\n    this.level = newPriority;\n  }\n\n  get priority() {\n    return this.level;\n  }\n\n  getPriority() {\n    return this.level;\n  }\n\n  enable() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this._storage.updateConfiguration({\n      enabled\n    });\n\n    return this;\n  }\n\n  setLevel(level) {\n    this._storage.updateConfiguration({\n      level\n    });\n\n    return this;\n  }\n\n  get(setting) {\n    return this._storage.config[setting];\n  }\n\n  set(setting, value) {\n    this._storage.updateConfiguration({\n      [setting]: value\n    });\n  }\n\n  settings() {\n    if (console.table) {\n      console.table(this._storage.config);\n    } else {\n      console.log(this._storage.config);\n    }\n  }\n\n  assert(condition, message) {\n    assert$5(condition, message);\n  }\n\n  warn(message) {\n    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);\n  }\n\n  error(message) {\n    return this._getLogFunction(0, message, originalConsole.error, arguments);\n  }\n\n  deprecated(oldUsage, newUsage) {\n    return this.warn(\"`\".concat(oldUsage, \"` is deprecated and will be removed in a later version. Use `\").concat(newUsage, \"` instead\"));\n  }\n\n  removed(oldUsage, newUsage) {\n    return this.error(\"`\".concat(oldUsage, \"` has been removed. Use `\").concat(newUsage, \"` instead\"));\n  }\n\n  probe(logLevel, message) {\n    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {\n      time: true,\n      once: true\n    });\n  }\n\n  log(logLevel, message) {\n    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);\n  }\n\n  info(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.info, arguments);\n  }\n\n  once(logLevel, message) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);\n  }\n\n  table(logLevel, table, columns) {\n    if (table) {\n      return this._getLogFunction(logLevel, table, console.table || noop$1, columns && [columns], {\n        tag: getTableHeader(table)\n      });\n    }\n\n    return noop$1;\n  }\n\n  image(_ref) {\n    let {\n      logLevel,\n      priority,\n      image,\n      message = '',\n      scale = 1\n    } = _ref;\n\n    if (!this._shouldLog(logLevel || priority)) {\n      return noop$1;\n    }\n\n    return isBrowser ? logImageInBrowser({\n      image,\n      message,\n      scale\n    }) : logImageInNode({\n      image,\n      message,\n      scale\n    });\n  }\n\n  time(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);\n  }\n\n  timeEnd(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);\n  }\n\n  timeStamp(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.timeStamp || noop$1);\n  }\n\n  group(logLevel, message) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      collapsed: false\n    };\n    const options = normalizeArguments({\n      logLevel,\n      message,\n      opts\n    });\n    const {\n      collapsed\n    } = opts;\n    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;\n    return this._getLogFunction(options);\n  }\n\n  groupCollapsed(logLevel, message) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.group(logLevel, message, Object.assign({}, opts, {\n      collapsed: true\n    }));\n  }\n\n  groupEnd(logLevel) {\n    return this._getLogFunction(logLevel, '', console.groupEnd || noop$1);\n  }\n\n  withGroup(logLevel, message, func) {\n    this.group(logLevel, message)();\n\n    try {\n      func();\n    } finally {\n      this.groupEnd(logLevel)();\n    }\n  }\n\n  trace() {\n    if (console.trace) {\n      console.trace();\n    }\n  }\n\n  _shouldLog(logLevel) {\n    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);\n  }\n\n  _getLogFunction(logLevel, message, method, args, opts) {\n    if (this._shouldLog(logLevel)) {\n      opts = normalizeArguments({\n        logLevel,\n        message,\n        args,\n        opts\n      });\n      method = method || opts.method;\n      assert$5(method);\n      opts.total = this.getTotal();\n      opts.delta = this.getDelta();\n      this._deltaTs = getHiResTimestamp();\n      const tag = opts.tag || opts.message;\n\n      if (opts.once) {\n        if (!cache[tag]) {\n          cache[tag] = getHiResTimestamp();\n        } else {\n          return noop$1;\n        }\n      }\n\n      message = decorateMessage(this.id, opts.message, opts);\n      return method.bind(console, message, ...opts.args);\n    }\n\n    return noop$1;\n  }\n\n}\n\n_defineProperty(Log, \"VERSION\", VERSION$6);\n\nfunction normalizeLogLevel(logLevel) {\n  if (!logLevel) {\n    return 0;\n  }\n\n  let resolvedLevel;\n\n  switch (typeof logLevel) {\n    case 'number':\n      resolvedLevel = logLevel;\n      break;\n\n    case 'object':\n      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;\n      break;\n\n    default:\n      return 0;\n  }\n\n  assert$5(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);\n  return resolvedLevel;\n}\n\nfunction normalizeArguments(opts) {\n  const {\n    logLevel,\n    message\n  } = opts;\n  opts.logLevel = normalizeLogLevel(logLevel);\n  const args = opts.args ? Array.from(opts.args) : [];\n\n  while (args.length && args.shift() !== message) {}\n\n  switch (typeof logLevel) {\n    case 'string':\n    case 'function':\n      if (message !== undefined) {\n        args.unshift(message);\n      }\n\n      opts.message = logLevel;\n      break;\n\n    case 'object':\n      Object.assign(opts, logLevel);\n      break;\n  }\n\n  if (typeof opts.message === 'function') {\n    opts.message = opts.message();\n  }\n\n  const messageType = typeof opts.message;\n  assert$5(messageType === 'string' || messageType === 'object');\n  return Object.assign(opts, {\n    args\n  }, opts.opts);\n}\n\nfunction decorateMessage(id, message, opts) {\n  if (typeof message === 'string') {\n    const time = opts.time ? leftPad(formatTime(opts.total)) : '';\n    message = opts.time ? \"\".concat(id, \": \").concat(time, \"  \").concat(message) : \"\".concat(id, \": \").concat(message);\n    message = addColor(message, opts.color, opts.background);\n  }\n\n  return message;\n}\n\nfunction logImageInNode(_ref2) {\n  let {\n    image,\n    message = '',\n    scale = 1\n  } = _ref2;\n  let asciify = null;\n\n  try {\n    asciify = module.require('asciify-image');\n  } catch (error) {}\n\n  if (asciify) {\n    return () => asciify(image, {\n      fit: 'box',\n      width: \"\".concat(Math.round(80 * scale), \"%\")\n    }).then(data => console.log(data));\n  }\n\n  return noop$1;\n}\n\nfunction logImageInBrowser(_ref3) {\n  let {\n    image,\n    message = '',\n    scale = 1\n  } = _ref3;\n\n  if (typeof image === 'string') {\n    const img = new Image();\n\n    img.onload = () => {\n      const args = formatImage(img, message, scale);\n      console.log(...args);\n    };\n\n    img.src = image;\n    return noop$1;\n  }\n\n  const element = image.nodeName || '';\n\n  if (element.toLowerCase() === 'img') {\n    console.log(...formatImage(image, message, scale));\n    return noop$1;\n  }\n\n  if (element.toLowerCase() === 'canvas') {\n    const img = new Image();\n\n    img.onload = () => console.log(...formatImage(img, message, scale));\n\n    img.src = image.toDataURL();\n    return noop$1;\n  }\n\n  return noop$1;\n}\n\nfunction getTableHeader(table) {\n  for (const key in table) {\n    for (const title in table[key]) {\n      return title || 'untitled';\n    }\n  }\n\n  return 'empty';\n}\n\nconst probeLog = new Log({\n  id: 'loaders.gl'\n});\nclass NullLog {\n  log() {\n    return () => {};\n  }\n\n  info() {\n    return () => {};\n  }\n\n  warn() {\n    return () => {};\n  }\n\n  error() {\n    return () => {};\n  }\n\n}\nclass ConsoleLog {\n  constructor() {\n    _defineProperty(this, \"console\", void 0);\n\n    this.console = console;\n  }\n\n  log(...args) {\n    return this.console.log.bind(this.console, ...args);\n  }\n\n  info(...args) {\n    return this.console.info.bind(this.console, ...args);\n  }\n\n  warn(...args) {\n    return this.console.warn.bind(this.console, ...args);\n  }\n\n  error(...args) {\n    return this.console.error.bind(this.console, ...args);\n  }\n\n}\n\nconst DEFAULT_LOADER_OPTIONS = {\n  fetch: null,\n  mimeType: undefined,\n  nothrow: false,\n  log: new ConsoleLog(),\n  CDN: 'https://unpkg.com/@loaders.gl',\n  worker: true,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: true,\n  _workerType: '',\n  limit: 0,\n  _limitMB: 0,\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  metadata: false,\n  transforms: []\n};\nconst REMOVED_LOADER_OPTIONS = {\n  throws: 'nothrow',\n  dataType: '(no longer used)',\n  uri: 'baseUri',\n  method: 'fetch.method',\n  headers: 'fetch.headers',\n  body: 'fetch.body',\n  mode: 'fetch.mode',\n  credentials: 'fetch.credentials',\n  cache: 'fetch.cache',\n  redirect: 'fetch.redirect',\n  referrer: 'fetch.referrer',\n  referrerPolicy: 'fetch.referrerPolicy',\n  integrity: 'fetch.integrity',\n  keepalive: 'fetch.keepalive',\n  signal: 'fetch.signal'\n};\n\nfunction getGlobalLoaderState() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders\n  } = globalThis;\n  loaders._state = loaders._state || {};\n  return loaders._state;\n}\n\nconst getGlobalLoaderOptions = () => {\n  const state = getGlobalLoaderState();\n  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS\n  };\n  return state.globalOptions;\n};\nfunction normalizeOptions(options, loader, loaders, url) {\n  loaders = loaders || [];\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  validateOptions(options, loaders);\n  return normalizeOptionsInternal(loader, options, url);\n}\nfunction getFetchFunction(options, context) {\n  const globalOptions = getGlobalLoaderOptions();\n  const fetchOptions = options || globalOptions;\n\n  if (typeof fetchOptions.fetch === 'function') {\n    return fetchOptions.fetch;\n  }\n\n  if (isObject(fetchOptions.fetch)) {\n    return url => fetchFile(url, fetchOptions);\n  }\n\n  if (context !== null && context !== void 0 && context.fetch) {\n    return context === null || context === void 0 ? void 0 : context.fetch;\n  }\n\n  return fetchFile;\n}\n\nfunction validateOptions(options, loaders) {\n  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n\n  for (const loader of loaders) {\n    const idOptions = options && options[loader.id] || {};\n    const loaderOptions = loader.options && loader.options[loader.id] || {};\n    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};\n    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n  }\n}\n\nfunction validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {\n  const loaderName = id || 'Top level';\n  const prefix = id ? \"\".concat(id, \".\") : '';\n\n  for (const key in options) {\n    const isSubOptions = !id && isObject(options[key]);\n    const isBaseUriOption = key === 'baseUri' && !id;\n    const isWorkerUrlOption = key === 'workerUrl' && id;\n\n    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n      if (key in deprecatedOptions) {\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' no longer supported, use '\").concat(deprecatedOptions[key], \"'\"))();\n      } else if (!isSubOptions) {\n        const suggestion = findSimilarOption(key, loaders);\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' not recognized. \").concat(suggestion))();\n      }\n    }\n  }\n}\n\nfunction findSimilarOption(optionKey, loaders) {\n  const lowerCaseOptionKey = optionKey.toLowerCase();\n  let bestSuggestion = '';\n\n  for (const loader of loaders) {\n    for (const key in loader.options) {\n      if (optionKey === key) {\n        return \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n\n      const lowerCaseKey = key.toLowerCase();\n      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n\n      if (isPartialMatch) {\n        bestSuggestion = bestSuggestion || \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n    }\n  }\n\n  return bestSuggestion;\n}\n\nfunction normalizeOptionsInternal(loader, options, url) {\n  const loaderDefaultOptions = loader.options || {};\n  const mergedOptions = { ...loaderDefaultOptions\n  };\n  addUrlOptions(mergedOptions, url);\n\n  if (mergedOptions.log === null) {\n    mergedOptions.log = new NullLog();\n  }\n\n  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n  mergeNestedFields(mergedOptions, options);\n  return mergedOptions;\n}\n\nfunction mergeNestedFields(mergedOptions, options) {\n  for (const key in options) {\n    if (key in options) {\n      const value = options[key];\n\n      if (isPureObject(value) && isPureObject(mergedOptions[key])) {\n        mergedOptions[key] = { ...mergedOptions[key],\n          ...options[key]\n        };\n      } else {\n        mergedOptions[key] = options[key];\n      }\n    }\n  }\n}\n\nfunction addUrlOptions(options, url) {\n  if (url && !('baseUri' in options)) {\n    options.baseUri = url;\n  }\n}\n\nfunction isLoaderObject(loader) {\n  var _loader;\n\n  if (!loader) {\n    return false;\n  }\n\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n\n  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);\n  return hasExtensions;\n}\nfunction normalizeLoader(loader) {\n  var _loader2, _loader3;\n\n  assert$7(loader, 'null loader');\n  assert$7(isLoaderObject(loader), 'invalid loader');\n  let options;\n\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = { ...loader,\n      options: { ...loader.options,\n        ...options\n      }\n    };\n  }\n\n  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {\n    loader.text = true;\n  }\n\n  if (!loader.text) {\n    loader.binary = true;\n  }\n\n  return loader;\n}\n\nconst getGlobalLoaderRegistry = () => {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = state.loaderRegistry || [];\n  return state.loaderRegistry;\n};\nfunction getRegisteredLoaders() {\n  return getGlobalLoaderRegistry();\n}\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\nasync function selectLoader(data, loaders = [], options, context) {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  let loader = selectLoaderSync(data, loaders, { ...options,\n    nothrow: true\n  }, context);\n\n  if (loader) {\n    return loader;\n  }\n\n  if (isBlob(data)) {\n    data = await data.slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\nfunction selectLoaderSync(data, loaders = [], options, context) {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  let candidateLoaders = [];\n\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n\n  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  normalizeLoaders(candidateLoaders);\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\nfunction selectLoaderInternal(data, loaders, options, context) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);\n  let loader = null;\n\n  if (options !== null && options !== void 0 && options.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);\n  }\n\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);\n  return loader;\n}\n\nfunction validHTTPResponse(data) {\n  if (data instanceof Response) {\n    if (data.status === 204) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  let message = 'No valid loader found (';\n  message += url ? \"\".concat(filename(url), \", \") : 'no url provided, ';\n  message += \"MIME type: \".concat(type ? \"\\\"\".concat(type, \"\\\"\") : 'not provided', \", \");\n  const firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? \" first bytes: \\\"\".concat(firstCharacters, \"\\\"\") : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    if (mimeType === \"application/x.\".concat(loader.id)) {\n      return loader;\n    }\n  }\n\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => data.startsWith(test));\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      const magic = getMagicString$2(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString$2(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString$2(data, byteOffset, length);\n  }\n\n  return '';\n}\n\nfunction getMagicString$2(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}\n\nconst DEFAULT_CHUNK_SIZE$2 = 256 * 1024;\nfunction* makeStringIterator(string, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE$2;\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n\n  while (offset < string.length) {\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n    yield textEncoder.encode(chunk);\n  }\n}\n\nconst DEFAULT_CHUNK_SIZE$1 = 256 * 1024;\nfunction* makeArrayBufferIterator(arrayBuffer, options = {}) {\n  const {\n    chunkSize = DEFAULT_CHUNK_SIZE$1\n  } = options;\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024;\nasync function* makeBlobIterator(blob, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n\n  while (offset < blob.size) {\n    const end = offset + chunkSize;\n    const chunk = await blob.slice(offset, end).arrayBuffer();\n    offset = end;\n    yield chunk;\n  }\n}\n\nfunction makeStreamIterator(stream, options) {\n  return isBrowser$2 ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream);\n}\n\nasync function* makeBrowserStreamIterator(stream, options) {\n  const reader = stream.getReader();\n  let nextBatchPromise;\n\n  try {\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n\n      if (options !== null && options !== void 0 && options._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n\n      const {\n        done,\n        value\n      } = await currentBatchPromise;\n\n      if (done) {\n        return;\n      }\n\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    reader.releaseLock();\n  }\n}\n\nasync function* makeNodeStreamIterator(stream, options) {\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk);\n  }\n}\n\nfunction makeIterator(data, options) {\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data, options);\n  }\n\n  if (isResponse(data)) {\n    const response = data;\n    return makeStreamIterator(response.body, options);\n  }\n\n  throw new Error('makeIterator');\n}\n\nconst ERR_DATA = 'Cannot convert supplied data type';\nfunction getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (isBuffer(data)) {\n    data = data.buffer;\n  }\n\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n\n    return arrayBuffer;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n\n    let arrayBuffer = data.buffer;\n    const byteLength = data.byteLength || data.length;\n\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\nasync function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader);\n  }\n\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n\n  if (isReadableStream(data)) {\n    data = makeIterator(data, options);\n  }\n\n  if (isIterable(data) || isAsyncIterable(data)) {\n    return concatenateArrayBuffersAsync(data);\n  }\n\n  throw new Error(ERR_DATA);\n}\n\nfunction getLoaderContext(context, options, previousContext = null) {\n  if (previousContext) {\n    return previousContext;\n  }\n\n  const resolvedContext = {\n    fetch: getFetchFunction(options, context),\n    ...context\n  };\n\n  if (!Array.isArray(resolvedContext.loaders)) {\n    resolvedContext.loaders = null;\n  }\n\n  return resolvedContext;\n}\nfunction getLoadersFromContext(loaders, context) {\n  if (!context && loaders && !Array.isArray(loaders)) {\n    return loaders;\n  }\n\n  let candidateLoaders;\n\n  if (loaders) {\n    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\n  }\n\n  if (context && context.loaders) {\n    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\n    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\n  }\n\n  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;\n}\n\nasync function parse$3(data, loaders, options, context) {\n  assert$6(!context || typeof context === 'object');\n\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  data = await data;\n  options = options || {};\n  const {\n    url\n  } = getResourceUrlAndType(data);\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = await selectLoader(data, candidateLoaders, options);\n\n  if (!loader) {\n    return null;\n  }\n\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n  context = getLoaderContext({\n    url,\n    parse: parse$3,\n    loaders: candidateLoaders\n  }, options, context);\n  return await parseWithLoader(loader, data, options, context);\n}\n\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse$3);\n  }\n\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  assert$6(!loader.parseSync);\n  throw new Error(\"\".concat(loader.id, \" loader - no parser found and worker is disabled\"));\n}\n\nasync function load(url, loaders, options, context) {\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    options = loaders;\n    loaders = undefined;\n  }\n\n  const fetch = getFetchFunction(options);\n  let data = url;\n\n  if (typeof url === 'string') {\n    data = await fetch(url);\n  }\n\n  if (isBlob(url)) {\n    data = await fetch(url);\n  }\n\n  return await parse$3(data, loaders, options);\n}\n\nfunction assert$4(condition, message) {\n  if (!condition) {\n    throw new Error(\"math.gl assertion \".concat(message));\n  }\n}\n\nconst RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nconst DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nconst config = {};\nconfig.EPSILON = 1e-12;\nconfig.debug = false;\nconfig.precision = 4;\nconfig.printTypes = false;\nconfig.printDegrees = false;\nconfig.printRowMajor = true;\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nfunction formatValue(value, {\n  precision = config.precision || 4\n} = {}) {\n  value = round(value);\n  return \"\".concat(parseFloat(value.toPrecision(precision)));\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nfunction map$1(value, func, result) {\n  if (isArray(value)) {\n    result = result || duplicateArray(value);\n\n    for (let i = 0; i < result.length && i < value.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n\n    return result;\n  }\n\n  return func(value);\n}\n\nfunction toRadians(degrees) {\n  return radians(degrees);\n}\nfunction toDegrees(radians) {\n  return degrees(radians);\n}\nfunction radians(degrees, result) {\n  return map$1(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\nfunction degrees(radians, result) {\n  return map$1(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\nfunction clamp(value, min, max) {\n  return map$1(value, value => Math.max(min, Math.min(max, value)));\n}\nfunction equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n\n  try {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < a.length; ++i) {\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n\n    if (Number.isFinite(a) && Number.isFinite(b)) {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\n\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\nclass MathArray extends _extendableBuiltin(Array) {\n  get ELEMENTS() {\n    assert$4(false);\n    return 0;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  from(arrayOrObject) {\n    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = array[i + offset];\n    }\n\n    return this.check();\n  }\n\n  to(arrayOrObject) {\n    if (arrayOrObject === this) {\n      return this;\n    }\n\n    return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);\n  }\n\n  toTarget(target) {\n    return target ? this.to(target) : this;\n  }\n\n  toArray(array = [], offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      array[offset + i] = this[i];\n    }\n\n    return array;\n  }\n\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toString() {\n    return this.formatString(config);\n  }\n\n  formatString(opts) {\n    let string = '';\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      string += (i > 0 ? ', ' : '') + formatValue(this[i], opts);\n    }\n\n    return \"\".concat(opts.printTypes ? this.constructor.name : '', \"[\").concat(string, \"]\");\n  }\n\n  equals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (!equals(this[i], array[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  exactEquals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (this[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  negate() {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = -this[i];\n    }\n\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    if (t === undefined) {\n      t = b;\n      b = a;\n      a = this;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const ai = a[i];\n      this[i] = ai + t * (b[i] - ai);\n    }\n\n    return this.check();\n  }\n\n  min(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  max(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.max(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  clamp(minVector, maxVector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);\n    }\n\n    return this.check();\n  }\n\n  add(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] += vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  subtract(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] -= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  scale(scale) {\n    if (Array.isArray(scale)) {\n      return this.multiply(scale);\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scale;\n    }\n\n    return this.check();\n  }\n\n  sub(a) {\n    return this.subtract(a);\n  }\n\n  setScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = a;\n    }\n\n    return this.check();\n  }\n\n  addScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] += a;\n    }\n\n    return this.check();\n  }\n\n  subScalar(a) {\n    return this.addScalar(-a);\n  }\n\n  multiplyScalar(scalar) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scalar;\n    }\n\n    return this.check();\n  }\n\n  divideScalar(a) {\n    return this.scale(1 / a);\n  }\n\n  clampScalar(min, max) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], min), max);\n    }\n\n    return this.check();\n  }\n\n  multiplyByScalar(scalar) {\n    return this.scale(scalar);\n  }\n\n  get elements() {\n    return this;\n  }\n\n  check() {\n    if (config.debug && !this.validate()) {\n      throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = this.length === this.ELEMENTS;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      valid = valid && Number.isFinite(this[i]);\n    }\n\n    return valid;\n  }\n\n}\n\nfunction validateVector(v, length) {\n  if (v.length !== length) {\n    return false;\n  }\n\n  for (let i = 0; i < v.length; ++i) {\n    if (!Number.isFinite(v[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction checkNumber(value) {\n  if (!Number.isFinite(value)) {\n    throw new Error(\"Invalid number \".concat(value));\n  }\n\n  return value;\n}\nfunction checkVector(v, length, callerName = '') {\n  if (config.debug && !validateVector(v, length)) {\n    throw new Error(\"math.gl: \".concat(callerName, \" some fields set to invalid numbers'\"));\n  }\n\n  return v;\n}\nconst map = {};\nfunction deprecated(method, version) {\n  if (!map[method]) {\n    map[method] = true;\n    console.warn(\"\".concat(method, \" has been removed in version \").concat(version, \", see upgrade guide for more information\"));\n  }\n}\n\nclass Vector extends MathArray {\n  get ELEMENTS() {\n    assert$4(false);\n    return 0;\n  }\n\n  copy(vector) {\n    assert$4(false);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  magnitude() {\n    return this.len();\n  }\n\n  lengthSquared() {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      length += this[i] * this[i];\n    }\n\n    return length;\n  }\n\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n\n  distance(mathArray) {\n    return Math.sqrt(this.distanceSquared(mathArray));\n  }\n\n  distanceSquared(mathArray) {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const dist = this[i] - mathArray[i];\n      length += dist * dist;\n    }\n\n    return checkNumber(length);\n  }\n\n  dot(mathArray) {\n    let product = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      product += this[i] * mathArray[i];\n    }\n\n    return checkNumber(product);\n  }\n\n  normalize() {\n    const length = this.magnitude();\n\n    if (length !== 0) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= length;\n      }\n    }\n\n    return this.check();\n  }\n\n  multiply(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] *= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  divide(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  distanceTo(vector) {\n    return this.distance(vector);\n  }\n\n  distanceToSquared(vector) {\n    return this.distanceSquared(vector);\n  }\n\n  getComponent(i) {\n    assert$4(i >= 0 && i < this.ELEMENTS, 'index is out of range');\n    return checkNumber(this[i]);\n  }\n\n  setComponent(i, value) {\n    assert$4(i >= 0 && i < this.ELEMENTS, 'index is out of range');\n    this[i] = value;\n    return this.check();\n  }\n\n  addVectors(a, b) {\n    return this.copy(a).add(b);\n  }\n\n  subVectors(a, b) {\n    return this.copy(a).subtract(b);\n  }\n\n  multiplyVectors(a, b) {\n    return this.copy(a).multiply(b);\n  }\n\n  addScaledVector(a, b) {\n    return this.add(new this.constructor(a).multiplyScalar(b));\n  }\n\n}\n\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nfunction create$4() {\n  var out = new ARRAY_TYPE(2);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat3$1(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nfunction transformMat4$2(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\n(function () {\n  var vec = create$4();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n})();\n\nfunction vec2_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const w = m[3] * x + m[7] * y || 1.0;\n  out[0] = (m[0] * x + m[4] * y) / w;\n  out[1] = (m[1] * x + m[5] * y) / w;\n  return out;\n}\nfunction vec3_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n  return out;\n}\nfunction vec3_transformMat2(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  out[2] = a[2];\n  return out;\n}\nfunction vec4_transformMat3(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[3] * y + m[6] * z;\n  out[1] = m[1] * x + m[4] * y + m[7] * z;\n  out[2] = m[2] * x + m[5] * y + m[8] * z;\n  out[3] = a[3];\n  return out;\n}\n\nclass Vector2 extends Vector {\n  constructor(x = 0, y = 0) {\n    super(2);\n\n    if (isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      if (config.debug) {\n        checkNumber(x);\n        checkNumber(y);\n      }\n\n      this[0] = x;\n      this[1] = y;\n    }\n  }\n\n  set(x, y) {\n    this[0] = x;\n    this[1] = y;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (config.debug) {\n      checkNumber(object.x);\n      checkNumber(object.y);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    return this.check();\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 2;\n  }\n\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n\n  transform(matrix4) {\n    return this.transformAsPoint(matrix4);\n  }\n\n  transformAsPoint(matrix4) {\n    transformMat4$2(this, this, matrix4);\n    return this.check();\n  }\n\n  transformAsVector(matrix4) {\n    vec2_transformMat4AsVector(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    transformMat3$1(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2x3(matrix2x3) {\n    transformMat2d(this, this, matrix2x3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    transformMat2(this, this, matrix2);\n    return this.check();\n  }\n\n}\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction create$3() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length$2(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction fromValues(x, y, z) {\n  var out = new ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nfunction normalize$2(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot$2(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat4$1(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformQuat$1(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateX$2(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateY$2(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateZ$2(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot$2(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nvar len = length$2;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\n(function () {\n  var vec = create$3();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\nconst ORIGIN = [0, 0, 0];\nconst constants$2 = {};\nclass Vector3 extends Vector {\n  static get ZERO() {\n    return constants$2.ZERO = constants$2.ZERO || Object.freeze(new Vector3(0, 0, 0, 0));\n  }\n\n  constructor(x = 0, y = 0, z = 0) {\n    super(-0, -0, -0);\n\n    if (arguments.length === 1 && isArray(x)) {\n      this.copy(x);\n    } else {\n      if (config.debug) {\n        checkNumber(x);\n        checkNumber(y);\n        checkNumber(z);\n      }\n\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n    }\n  }\n\n  set(x, y, z) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (config.debug) {\n      checkNumber(object.x);\n      checkNumber(object.y);\n      checkNumber(object.z);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    return this.check();\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    object.z = this[2];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 3;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n\n  angle(vector) {\n    return angle(this, vector);\n  }\n\n  cross(vector) {\n    cross(this, this, vector);\n    return this.check();\n  }\n\n  rotateX({\n    radians,\n    origin = ORIGIN\n  }) {\n    rotateX$2(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateY({\n    radians,\n    origin = ORIGIN\n  }) {\n    rotateY$2(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateZ({\n    radians,\n    origin = ORIGIN\n  }) {\n    rotateZ$2(this, this, origin, radians);\n    return this.check();\n  }\n\n  transform(matrix4) {\n    return this.transformAsPoint(matrix4);\n  }\n\n  transformAsPoint(matrix4) {\n    transformMat4$1(this, this, matrix4);\n    return this.check();\n  }\n\n  transformAsVector(matrix4) {\n    vec3_transformMat4AsVector(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    transformMat3(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    vec3_transformMat2(this, this, matrix2);\n    return this.check();\n  }\n\n  transformByQuaternion(quaternion) {\n    transformQuat$1(this, this, quaternion);\n    return this.check();\n  }\n\n}\n\nclass Matrix extends MathArray {\n  get ELEMENTS() {\n    assert$4(false);\n    return 0;\n  }\n\n  get RANK() {\n    assert$4(false);\n    return 0;\n  }\n\n  toString() {\n    let string = '[';\n\n    if (config.printRowMajor) {\n      string += 'row-major:';\n\n      for (let row = 0; row < this.RANK; ++row) {\n        for (let col = 0; col < this.RANK; ++col) {\n          string += \" \".concat(this[col * this.RANK + row]);\n        }\n      }\n    } else {\n      string += 'column-major:';\n\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        string += \" \".concat(this[i]);\n      }\n    }\n\n    string += ']';\n    return string;\n  }\n\n  getElementIndex(row, col) {\n    return col * this.RANK + row;\n  }\n\n  getElement(row, col) {\n    return this[col * this.RANK + row];\n  }\n\n  setElement(row, col, value) {\n    this[col * this.RANK + row] = checkNumber(value);\n    return this;\n  }\n\n  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      result[i] = this[firstIndex + i];\n    }\n\n    return result;\n  }\n\n  setColumn(columnIndex, columnVector) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      this[firstIndex + i] = columnVector[i];\n    }\n\n    return this;\n  }\n\n}\n\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\n\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nfunction create$2() {\n  var out = new ARRAY_TYPE(9);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction transpose$1(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nfunction invert$2(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant$1(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nfunction multiply$2(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to translate\r\n * @param {ReadonlyVec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\n\nfunction translate$1(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nfunction rotate$1(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\n\nfunction scale$3(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Calculates a 3x3 matrix from the given quaternion\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat3} out\r\n */\n\nfunction fromQuat$1(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n\nconst IDENTITY$1 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nconst ZERO$1 = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst INDICES$1 = Object.freeze({\n  COL0ROW0: 0,\n  COL0ROW1: 1,\n  COL0ROW2: 2,\n  COL1ROW0: 3,\n  COL1ROW1: 4,\n  COL1ROW2: 5,\n  COL2ROW0: 6,\n  COL2ROW1: 7,\n  COL2ROW2: 8\n});\nconst constants$1 = {};\nclass Matrix3 extends Matrix {\n  static get IDENTITY() {\n    constants$1.IDENTITY = constants$1.IDENTITY || Object.freeze(new Matrix3(IDENTITY$1));\n    return constants$1.IDENTITY;\n  }\n\n  static get ZERO() {\n    constants$1.ZERO = constants$1.ZERO || Object.freeze(new Matrix3(ZERO$1));\n    return constants$1.ZERO;\n  }\n\n  get ELEMENTS() {\n    return 9;\n  }\n\n  get RANK() {\n    return 3;\n  }\n\n  get INDICES() {\n    return INDICES$1;\n  }\n\n  constructor(array) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    return this.check();\n  }\n\n  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  determinant() {\n    return determinant$1(this);\n  }\n\n  identity() {\n    return this.copy(IDENTITY$1);\n  }\n\n  fromQuaternion(q) {\n    fromQuat$1(this, q);\n    return this.check();\n  }\n\n  transpose() {\n    transpose$1(this, this);\n    return this.check();\n  }\n\n  invert() {\n    invert$2(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    multiply$2(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    multiply$2(this, this, a);\n    return this.check();\n  }\n\n  rotate(radians) {\n    rotate$1(this, this, radians);\n    return this.check();\n  }\n\n  scale(factor) {\n    if (Array.isArray(factor)) {\n      scale$3(this, this, factor);\n    } else {\n      scale$3(this, this, [factor, factor, factor]);\n    }\n\n    return this.check();\n  }\n\n  translate(vec) {\n    translate$1(this, this, vec);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    switch (vector.length) {\n      case 2:\n        result = transformMat3$1(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        result = transformMat3(result || [-0, -0, -0], vector, this);\n        break;\n\n      case 4:\n        result = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error('Illegal vector');\n    }\n\n    checkVector(result, vector.length);\n    return result;\n  }\n\n  transformVector(vector, result) {\n    deprecated('Matrix3.transformVector');\n    return this.transform(vector, result);\n  }\n\n  transformVector2(vector, result) {\n    deprecated('Matrix3.transformVector');\n    return this.transform(vector, result);\n  }\n\n  transformVector3(vector, result) {\n    deprecated('Matrix3.transformVector');\n    return this.transform(vector, result);\n  }\n\n}\n\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nfunction identity$1(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nfunction invert$1(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nfunction multiply$1(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nfunction scale$2(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateX$1(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateY$1(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nfunction rotateZ$1(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {\n    return identity$1(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nfunction create$1() {\n  var out = new ARRAY_TYPE(4);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nfunction add$1(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nfunction scale$1(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length$1(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength$1(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nfunction normalize$1(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot$1(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nfunction lerp$1(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\n(function () {\n  var vec = create$1();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n})();\n\nconst IDENTITY = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nconst ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst INDICES = Object.freeze({\n  COL0ROW0: 0,\n  COL0ROW1: 1,\n  COL0ROW2: 2,\n  COL0ROW3: 3,\n  COL1ROW0: 4,\n  COL1ROW1: 5,\n  COL1ROW2: 6,\n  COL1ROW3: 7,\n  COL2ROW0: 8,\n  COL2ROW1: 9,\n  COL2ROW2: 10,\n  COL2ROW3: 11,\n  COL3ROW0: 12,\n  COL3ROW1: 13,\n  COL3ROW2: 14,\n  COL3ROW3: 15\n});\nconst constants = {};\nclass Matrix4 extends Matrix {\n  static get IDENTITY() {\n    constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix4(IDENTITY));\n    return constants.IDENTITY;\n  }\n\n  static get ZERO() {\n    constants.ZERO = constants.ZERO || Object.freeze(new Matrix4(ZERO));\n    return constants.ZERO;\n  }\n\n  get INDICES() {\n    return INDICES;\n  }\n\n  get ELEMENTS() {\n    return 16;\n  }\n\n  get RANK() {\n    return 4;\n  }\n\n  constructor(array) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    this[9] = array[9];\n    this[10] = array[10];\n    this[11] = array[11];\n    this[12] = array[12];\n    this[13] = array[13];\n    this[14] = array[14];\n    this[15] = array[15];\n    return this.check();\n  }\n\n  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  toRowMajor(result) {\n    result[0] = this[0];\n    result[1] = this[4];\n    result[2] = this[8];\n    result[3] = this[12];\n    result[4] = this[1];\n    result[5] = this[5];\n    result[6] = this[9];\n    result[7] = this[13];\n    result[8] = this[2];\n    result[9] = this[6];\n    result[10] = this[10];\n    result[11] = this[14];\n    result[12] = this[3];\n    result[13] = this[7];\n    result[14] = this[11];\n    result[15] = this[15];\n    return result;\n  }\n\n  identity() {\n    return this.copy(IDENTITY);\n  }\n\n  fromQuaternion(q) {\n    fromQuat(this, q);\n    return this.check();\n  }\n\n  frustum({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  }) {\n    if (far === Infinity) {\n      Matrix4._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);\n    } else {\n      frustum(this, left, right, bottom, top, near, far);\n    }\n\n    return this.check();\n  }\n\n  static _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {\n    const column0Row0 = 2.0 * near / (right - left);\n    const column1Row1 = 2.0 * near / (top - bottom);\n    const column2Row0 = (right + left) / (right - left);\n    const column2Row1 = (top + bottom) / (top - bottom);\n    const column2Row2 = -1.0;\n    const column2Row3 = -1.0;\n    const column3Row2 = -2.0 * near;\n    result[0] = column0Row0;\n    result[1] = 0.0;\n    result[2] = 0.0;\n    result[3] = 0.0;\n    result[4] = 0.0;\n    result[5] = column1Row1;\n    result[6] = 0.0;\n    result[7] = 0.0;\n    result[8] = column2Row0;\n    result[9] = column2Row1;\n    result[10] = column2Row2;\n    result[11] = column2Row3;\n    result[12] = 0.0;\n    result[13] = 0.0;\n    result[14] = column3Row2;\n    result[15] = 0.0;\n    return result;\n  }\n\n  lookAt(eye, center, up) {\n    if (arguments.length === 1) {\n      ({\n        eye,\n        center,\n        up\n      } = eye);\n    }\n\n    center = center || [0, 0, 0];\n    up = up || [0, 1, 0];\n    lookAt(this, eye, center, up);\n    return this.check();\n  }\n\n  ortho({\n    left,\n    right,\n    bottom,\n    top,\n    near = 0.1,\n    far = 500\n  }) {\n    ortho(this, left, right, bottom, top, near, far);\n    return this.check();\n  }\n\n  orthographic({\n    fovy = 45 * Math.PI / 180,\n    aspect = 1,\n    focalDistance = 1,\n    near = 0.1,\n    far = 500\n  }) {\n    if (fovy > Math.PI * 2) {\n      throw Error('radians');\n    }\n\n    const halfY = fovy / 2;\n    const top = focalDistance * Math.tan(halfY);\n    const right = top * aspect;\n    return new Matrix4().ortho({\n      left: -right,\n      right,\n      bottom: -top,\n      top,\n      near,\n      far\n    });\n  }\n\n  perspective({\n    fovy = undefined,\n    fov = 45 * Math.PI / 180,\n    aspect = 1,\n    near = 0.1,\n    far = 500\n  } = {}) {\n    fovy = fovy || fov;\n\n    if (fovy > Math.PI * 2) {\n      throw Error('radians');\n    }\n\n    perspective(this, fovy, aspect, near, far);\n    return this.check();\n  }\n\n  determinant() {\n    return determinant(this);\n  }\n\n  getScale(result = [-0, -0, -0]) {\n    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);\n    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);\n    return result;\n  }\n\n  getTranslation(result = [-0, -0, -0]) {\n    result[0] = this[12];\n    result[1] = this[13];\n    result[2] = this[14];\n    return result;\n  }\n\n  getRotation(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {\n    const scale = this.getScale(scaleResult || [-0, -0, -0]);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = 0;\n    result[4] = this[4] * inverseScale0;\n    result[5] = this[5] * inverseScale1;\n    result[6] = this[6] * inverseScale2;\n    result[7] = 0;\n    result[8] = this[8] * inverseScale0;\n    result[9] = this[9] * inverseScale1;\n    result[10] = this[10] * inverseScale2;\n    result[11] = 0;\n    result[12] = 0;\n    result[13] = 0;\n    result[14] = 0;\n    result[15] = 1;\n    return result;\n  }\n\n  getRotationMatrix3(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {\n    const scale = this.getScale(scaleResult || [-0, -0, -0]);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = this[4] * inverseScale0;\n    result[4] = this[5] * inverseScale1;\n    result[5] = this[6] * inverseScale2;\n    result[6] = this[8] * inverseScale0;\n    result[7] = this[9] * inverseScale1;\n    result[8] = this[10] * inverseScale2;\n    return result;\n  }\n\n  transpose() {\n    transpose(this, this);\n    return this.check();\n  }\n\n  invert() {\n    invert$1(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    multiply$1(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    multiply$1(this, this, a);\n    return this.check();\n  }\n\n  rotateX(radians) {\n    rotateX$1(this, this, radians);\n    return this.check();\n  }\n\n  rotateY(radians) {\n    rotateY$1(this, this, radians);\n    return this.check();\n  }\n\n  rotateZ(radians) {\n    rotateZ$1(this, this, radians);\n    return this.check();\n  }\n\n  rotateXYZ([rx, ry, rz]) {\n    return this.rotateX(rx).rotateY(ry).rotateZ(rz);\n  }\n\n  rotateAxis(radians, axis) {\n    rotate(this, this, radians, axis);\n    return this.check();\n  }\n\n  scale(factor) {\n    if (Array.isArray(factor)) {\n      scale$2(this, this, factor);\n    } else {\n      scale$2(this, this, [factor, factor, factor]);\n    }\n\n    return this.check();\n  }\n\n  translate(vec) {\n    translate(this, this, vec);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    if (vector.length === 4) {\n      result = transformMat4(result || [-0, -0, -0, -0], vector, this);\n      checkVector(result, 4);\n      return result;\n    }\n\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformAsPoint(vector, result) {\n    const {\n      length\n    } = vector;\n\n    switch (length) {\n      case 2:\n        result = transformMat4$2(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        result = transformMat4$1(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error('Illegal vector');\n    }\n\n    checkVector(result, vector.length);\n    return result;\n  }\n\n  transformAsVector(vector, result) {\n    switch (vector.length) {\n      case 2:\n        result = vec2_transformMat4AsVector(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        result = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error('Illegal vector');\n    }\n\n    checkVector(result, vector.length);\n    return result;\n  }\n\n  makeRotationX(radians) {\n    return this.identity().rotateX(radians);\n  }\n\n  makeTranslation(x, y, z) {\n    return this.identity().translate([x, y, z]);\n  }\n\n  transformPoint(vector, result) {\n    deprecated('Matrix4.transformPoint', '3.0');\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformVector(vector, result) {\n    deprecated('Matrix4.transformVector', '3.0');\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformDirection(vector, result) {\n    deprecated('Matrix4.transformDirection', '3.0');\n    return this.transformAsVector(vector, result);\n  }\n\n}\n\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyVec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n */\n\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyMat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar add = add$1;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {ReadonlyQuat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar scale = scale$1;\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nvar dot = dot$1;\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar lerp = lerp$1;\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nvar length = length$1;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nvar squaredLength = squaredLength$1;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nvar normalize = normalize$1;\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {ReadonlyVec3} a the initial vector\r\n * @param {ReadonlyVec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nvar rotationTo = function () {\n  var tmpvec3 = create$3();\n  var xUnitVec3 = fromValues(1, 0, 0);\n  var yUnitVec3 = fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = dot$2(a, b);\n\n    if (dot < -0.999999) {\n      cross(tmpvec3, xUnitVec3, a);\n      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);\n      normalize$2(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {ReadonlyQuat} c the third operand\r\n * @param {ReadonlyQuat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\n(function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n})();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\r\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\r\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\n(function () {\n  var matr = create$2();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n})();\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nclass Quaternion extends MathArray {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    super(-0, -0, -0, -0);\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromMatrix3(m) {\n    fromMat3(this, m);\n    return this.check();\n  }\n\n  identity() {\n    identity(this);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = checkNumber(value);\n  }\n\n  len() {\n    return length(this);\n  }\n\n  lengthSquared() {\n    return squaredLength(this);\n  }\n\n  dot(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.dot only takes one argument');\n    }\n\n    return dot(this, a);\n  }\n\n  rotationTo(vectorA, vectorB) {\n    rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  add(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.add only takes one argument');\n    }\n\n    add(this, this, a);\n    return this.check();\n  }\n\n  calculateW() {\n    calculateW(this, this);\n    return this.check();\n  }\n\n  conjugate() {\n    conjugate(this, this);\n    return this.check();\n  }\n\n  invert() {\n    invert(this, this);\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    lerp(this, a, b, t);\n    return this.check();\n  }\n\n  multiplyRight(a, b) {\n    assert$4(!b);\n    multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a, b) {\n    assert$4(!b);\n    multiply(this, a, this);\n    return this.check();\n  }\n\n  normalize() {\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n\n    if (length === 0) {\n      this[3] = 1;\n    }\n\n    return this.check();\n  }\n\n  rotateX(rad) {\n    rotateX(this, this, rad);\n    return this.check();\n  }\n\n  rotateY(rad) {\n    rotateY(this, this, rad);\n    return this.check();\n  }\n\n  rotateZ(rad) {\n    rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  scale(b) {\n    scale(this, this, b);\n    return this.check();\n  }\n\n  slerp(start, target, ratio) {\n    switch (arguments.length) {\n      case 1:\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arguments[0]);\n        break;\n\n      case 2:\n        [target, ratio] = arguments;\n        start = this;\n        break;\n    }\n\n    slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector, result = vector) {\n    transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a, b) {\n    return this.multiplyLeft(a, b);\n  }\n\n  multiply(a, b) {\n    return this.multiplyRight(a, b);\n  }\n\n}\n\nvar _MathUtils = {\n  EPSILON1: 1e-1,\n  EPSILON2: 1e-2,\n  EPSILON3: 1e-3,\n  EPSILON4: 1e-4,\n  EPSILON5: 1e-5,\n  EPSILON6: 1e-6,\n  EPSILON7: 1e-7,\n  EPSILON8: 1e-8,\n  EPSILON9: 1e-9,\n  EPSILON10: 1e-10,\n  EPSILON11: 1e-11,\n  EPSILON12: 1e-12,\n  EPSILON13: 1e-13,\n  EPSILON14: 1e-14,\n  EPSILON15: 1e-15,\n  EPSILON16: 1e-16,\n  EPSILON17: 1e-17,\n  EPSILON18: 1e-18,\n  EPSILON19: 1e-19,\n  EPSILON20: 1e-20,\n  PI_OVER_TWO: Math.PI / 2,\n  PI_OVER_FOUR: Math.PI / 4,\n  PI_OVER_SIX: Math.PI / 6,\n  TWO_PI: Math.PI * 2\n};\n\nconst WGS84_RADIUS_X$1 = 6378137.0;\nconst WGS84_RADIUS_Y$1 = 6378137.0;\nconst WGS84_RADIUS_Z$1 = 6356752.3142451793;\n\nconst noop = x => x;\n\nconst scratchVector$6 = new Vector3();\nfunction fromCartographic(cartographic, result, map = noop) {\n  if (isArray(cartographic)) {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  } else if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  }\n\n  return result;\n}\nfunction fromCartographicToRadians(cartographic, vector = scratchVector$6) {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? noop : toRadians);\n}\nfunction toCartographic(vector, cartographic, map = noop) {\n  if (isArray(cartographic)) {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  } else if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  }\n\n  return cartographic;\n}\nfunction toCartographicFromRadians(vector, cartographic) {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? noop : toDegrees);\n}\n\nconst scratchVector$5 = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\nfunction scaleToGeodeticSurface(cartesian, ellipsoid, result = new Vector3()) {\n  const {\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared\n  } = ellipsoid;\n  scratchVector$5.from(cartesian);\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n  let lambda = (1.0 - ratio) * cartesian.len() / (0.5 * gradient.len());\n  let correction = 0.0;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    const derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector$5.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n\nconst EPSILON14 = 1e-14;\nconst scratchOrigin = new Vector3();\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n};\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\nconst scratchVector1 = new Vector3();\nconst scratchVector2$1 = new Vector3();\nconst scratchVector3$1 = new Vector3();\nfunction localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {\n  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  assert$4(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n  let firstAxisVector;\n  let secondAxisVector;\n  let thirdAxisVector;\n  const origin = scratchOrigin.copy(cartesianOrigin);\n  const atPole = equals(origin.x, 0.0, EPSILON14) && equals(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    const sign = Math.sign(origin.z);\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2$1.fromArray(degeneratePositionLocalFrame[secondAxis]);\n\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3$1.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    const {\n      up,\n      east,\n      north\n    } = scratchAxisVectors;\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n    const {\n      down,\n      west,\n      south\n    } = scratchAxisVectors;\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n\nconst scratchVector$4 = new Vector3();\nconst scratchNormal$2 = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition$2 = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\nlet wgs84;\nclass Ellipsoid {\n  static get WGS84() {\n    wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X$1, WGS84_RADIUS_Y$1, WGS84_RADIUS_Z$1);\n    return wgs84;\n  }\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert$4(x >= 0.0);\n    assert$4(y >= 0.0);\n    assert$4(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  toString() {\n    return this.radii.toString();\n  }\n\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal$2;\n    const k = scratchK;\n    const [,, height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n    normal.scale(height);\n    k.add(normal);\n    return k.to(result);\n  }\n\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition$2);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal$2);\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(dot$2(h, scratchCartesian)) * length$2(h);\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector$4.from(cartesian).normalize().to(result);\n  }\n\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n    const cosLatitude = Math.cos(latitude);\n    scratchVector$4.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n    return scratchVector$4.to(result);\n  }\n\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector$4.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition$2.from(cartesian);\n    const positionX = scratchPosition$2.x;\n    const positionY = scratchPosition$2.y;\n    const positionZ = scratchPosition$2.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n    const beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n    return scratchPosition$2.multiplyScalar(beta).to(result);\n  }\n\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition$2.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition$2.from(position).scale(this.radii).to(result);\n  }\n\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0.0, result = [0, 0, 0]) {\n    assert$4(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert$4(this.radii.z > 0);\n    scratchPosition$2.from(position);\n    const z = scratchPosition$2.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition$2.set(0.0, 0.0, z).to(result);\n  }\n\n}\n\nclass DoublyLinkedListNode {\n  constructor(item, previous, next) {\n    _defineProperty(this, \"item\", void 0);\n\n    _defineProperty(this, \"previous\", void 0);\n\n    _defineProperty(this, \"next\", void 0);\n\n    this.item = item;\n    this.previous = previous;\n    this.next = next;\n  }\n\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    _defineProperty(this, \"head\", null);\n\n    _defineProperty(this, \"tail\", null);\n\n    _defineProperty(this, \"_length\", 0);\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  add(item) {\n    const node = new DoublyLinkedListNode(item, this.tail, null);\n\n    if (this.tail) {\n      this.tail.next = node;\n      this.tail = node;\n    } else {\n      this.head = node;\n      this.tail = node;\n    }\n\n    ++this._length;\n    return node;\n  }\n\n  remove(node) {\n    if (!node) {\n      return;\n    }\n\n    if (node.previous && node.next) {\n      node.previous.next = node.next;\n      node.next.previous = node.previous;\n    } else if (node.previous) {\n      node.previous.next = null;\n      this.tail = node.previous;\n    } else if (node.next) {\n      node.next.previous = null;\n      this.head = node.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    node.next = null;\n    node.previous = null;\n    --this._length;\n  }\n\n  splice(node, nextNode) {\n    if (node === nextNode) {\n      return;\n    }\n\n    this.remove(nextNode);\n\n    this._insert(node, nextNode);\n  }\n\n  _insert(node, nextNode) {\n    const oldNodeNext = node.next;\n    node.next = nextNode;\n\n    if (this.tail === node) {\n      this.tail = nextNode;\n    } else {\n      oldNodeNext.previous = nextNode;\n    }\n\n    nextNode.next = oldNodeNext;\n    nextNode.previous = node;\n    ++this._length;\n  }\n\n}\n\nfunction defined$5(x) {\n  return x !== undefined && x !== null;\n}\n\nclass TilesetCache {\n  constructor() {\n    _defineProperty(this, \"_list\", void 0);\n\n    _defineProperty(this, \"_sentinel\", void 0);\n\n    _defineProperty(this, \"_trimTiles\", void 0);\n\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n\n    if (defined$5(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined$5(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback) {\n    const node = tile._cacheNode;\n\n    if (!defined$5(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n\n    tile._cacheNode = undefined;\n\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n    const list = this._list;\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {\n      const tile = node.item;\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n\n}\n\nfunction calculateTransformProps(tileHeader, tile) {\n  assert$7(tileHeader);\n  assert$7(tile);\n  const {\n    rtcCenter,\n    gltfUpAxis\n  } = tile;\n  const {\n    computedTransform,\n    boundingVolume: {\n      center\n    }\n  } = tileHeader;\n  let modelMatrix = new Matrix4(computedTransform);\n\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n  }\n\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  const cartesianOrigin = new Vector3(center);\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n\n  if (!tile.coordinateSystem) {\n    tile.modelMatrix = tile.cartographicModelMatrix;\n  }\n}\n\nconst INTERSECTION = Object.freeze({\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n});\n\nnew Vector3();\nnew Vector3();\n\nconst scratchVector$3 = new Vector3();\nconst scratchVector2 = new Vector3();\nclass BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector$3.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n  }\n\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n    const toRightCenter = scratchVector$3.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      return boundingSphere.clone();\n    }\n\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n    scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n    return this;\n  }\n\n  expand(point) {\n    point = scratchVector$3.from(point);\n    const radius = point.subtract(this.center).magnitude();\n\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n\n    return this;\n  }\n\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = getScaling(scratchVector$3, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  distanceTo(point) {\n    point = scratchVector$3.from(point);\n    const delta = point.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n\n    return INTERSECTION.INSIDE;\n  }\n\n}\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      return INTERSECTION.INSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    throw new Error('not implemented');\n  }\n\n}\n\nconst scratchPosition$1 = new Vector3();\nconst scratchNormal$1 = new Vector3();\nclass Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  fromNormalDistance(normal, distance) {\n    assert$4(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  fromPointNormal(point, normal) {\n    point = scratchPosition$1.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    assert$4(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  clone(plane) {\n    return new Plane(this.normal, this.distance);\n  }\n\n  equals(right) {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  transform(matrix4) {\n    const normal = scratchNormal$1.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition$1.from(point);\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal$1.copy(this.normal).scale(pointDistance);\n    return point.subtract(scaledNormal).to(result);\n  }\n\n}\n\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal$1 = new Vector3();\nnew Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\nclass CullingVolume {\n  static get MASK_OUTSIDE() {\n    return 0xffffffff;\n  }\n\n  static get MASK_INSIDE() {\n    return 0x00000000;\n  }\n\n  static get MASK_INDETERMINATE() {\n    return 0x7fffffff;\n  }\n\n  constructor(planes = []) {\n    this.planes = planes;\n    assert$4(this.planes.every(plane => plane instanceof Plane));\n  }\n\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      -faceNormal.dot(plane0Center);\n      plane0.fromPointNormal(plane0Center, faceNormal);\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n      const negatedFaceNormal = scratchPlaneNormal$1.copy(faceNormal).negate();\n      -negatedFaceNormal.dot(plane1Center);\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  computeVisibility(boundingVolume) {\n    assert$4(boundingVolume);\n    let intersect = INTERSECTION.INSIDE;\n\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n      }\n    }\n\n    return intersect;\n  }\n\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    assert$4(boundingVolume, 'boundingVolume is required.');\n    assert$4(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n      return parentPlaneMask;\n    }\n\n    let mask = CullingVolume.MASK_INSIDE;\n    const planes = this.planes;\n\n    for (let k = 0; k < this.planes.length; ++k) {\n      const flag = k < 31 ? 1 << k : 0;\n\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n\n}\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nclass PerspectiveOffCenterFrustum {\n  constructor(options = {}) {\n    options = {\n      near: 1.0,\n      far: 500000000.0,\n      ...options\n    };\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = options.near;\n    this._near = this.near;\n    this.far = options.far;\n    this._far = this.far;\n    this._cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n  }\n\n  clone() {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n  }\n\n  get projectionMatrix() {\n    update$1(this);\n    return this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    update$1(this);\n    return this._infinitePerspective;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    assert$4(position, 'position is required.');\n    assert$4(direction, 'direction is required.');\n    assert$4(up, 'up is required.');\n    const planes = this._cullingVolume.planes;\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n    let normal = scratchPlaneNormal;\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n    planes[0].fromPointNormal(position, normal);\n    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n    planes[1].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n    planes[2].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n    planes[3].fromPointNormal(position, normal);\n    normal = new Vector3().copy(direction);\n    planes[4].fromPointNormal(nearCenter, normal);\n    normal.negate();\n    planes[5].fromPointNormal(farCenter, normal);\n    return this._cullingVolume;\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    update$1(this);\n    assert$4(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    assert$4(drawingBufferWidth > 0);\n    assert$4(drawingBufferHeight > 0);\n    assert$4(distance > 0);\n    assert$4(result);\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n}\n\nfunction update$1(frustum) {\n  assert$4(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));\n  const {\n    top,\n    bottom,\n    right,\n    left,\n    near,\n    far\n  } = frustum;\n\n  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {\n    assert$4(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');\n    frustum._left = left;\n    frustum._right = right;\n    frustum._top = top;\n    frustum._bottom = bottom;\n    frustum._near = near;\n    frustum._far = far;\n    frustum._perspectiveMatrix = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    frustum._infinitePerspective = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far: Infinity\n    });\n  }\n}\n\nconst defined$4 = val => val !== null && typeof val !== 'undefined';\n\nclass PerspectiveFrustum {\n  constructor(options = {}) {\n    options = {\n      near: 1.0,\n      far: 500000000.0,\n      xOffset: 0.0,\n      yOffset: 0.0,\n      ...options\n    };\n    this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n    this.fov = options.fov;\n    this._fov = undefined;\n    this._fovy = undefined;\n    this._sseDenominator = undefined;\n    this.aspectRatio = options.aspectRatio;\n    this._aspectRatio = undefined;\n    this.near = options.near;\n    this._near = this.near;\n    this.far = options.far;\n    this._far = this.far;\n    this.xOffset = options.xOffset;\n    this._xOffset = this.xOffset;\n    this.yOffset = options.yOffset;\n    this._yOffset = this.yOffset;\n  }\n\n  clone() {\n    return new PerspectiveFrustum({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    if (!defined$4(other) || !(other instanceof PerspectiveFrustum)) {\n      return false;\n    }\n\n    update(this);\n    update(other);\n    return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);\n  }\n\n  get projectionMatrix() {\n    update(this);\n    return this._offCenterFrustum.projectionMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    update(this);\n    return this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  get fovy() {\n    update(this);\n    return this._fovy;\n  }\n\n  get sseDenominator() {\n    update(this);\n    return this._sseDenominator;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    update(this);\n    return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    update(this);\n    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);\n  }\n\n}\n\nfunction update(frustum) {\n  assert$4(Number.isFinite(frustum.fov) && Number.isFinite(frustum.aspectRatio) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));\n  const f = frustum._offCenterFrustum;\n\n  if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {\n    assert$4(frustum.fov >= 0 && frustum.fov < Math.PI);\n    assert$4(frustum.aspectRatio > 0);\n    assert$4(frustum.near >= 0 && frustum.near < frustum.far);\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\n\nnew Matrix3();\nnew Matrix3();\nnew Matrix3();\nnew Matrix3();\nnew Matrix3();\n\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Matrix3();\n({\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n});\n\nconst scratchVector$2 = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\nfunction getFrameState(viewport, frameNumber) {\n  const {\n    cameraDirection,\n    cameraUp,\n    height\n  } = viewport;\n  const {\n    metersPerUnit\n  } = viewport.distanceScales;\n  const viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  const viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(viewportCenterCartographic, new Vector3());\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  const cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  const cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    height,\n    cullingVolume,\n    frameNumber,\n    sseDenominator: 1.15\n  };\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  const frustumPlanes = viewport.getFrustumPlanes();\n  let i = 0;\n\n  for (const dir in frustumPlanes) {\n    const plane = frustumPlanes[dir];\n    const distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition.copy(plane.normal).scale(plane.distance - distanceToCenter).add(viewport.center);\n    const cartographicPos = viewport.unprojectPosition(scratchPosition);\n    const cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector$2.copy(viewportCenterCartesian).subtract(cartesianPos));\n  }\n}\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector$1 = new Vector3();\nfunction getZoomFromBoundingVolume(boundingVolume) {\n  const {\n    halfAxes,\n    radius,\n    width,\n    height\n  } = boundingVolume;\n\n  if (halfAxes) {\n    const obbSize = getObbSize(halfAxes);\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector$1);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector$1.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n\nconst TILE_CONTENT_STATE = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  EXPIRED: 4,\n  FAILED: 5\n};\nconst TILE_REFINEMENT = {\n  ADD: 1,\n  REPLACE: 2\n};\nconst TILE_TYPE = {\n  EMPTY: 'empty',\n  SCENEGRAPH: 'scenegraph',\n  POINTCLOUD: 'pointcloud',\n  MESH: 'mesh'\n};\nconst TILESET_TYPE = {\n  I3S: 'I3S',\n  TILES3D: 'TILES3D'\n};\nconst LOD_METRIC_TYPE = {\n  GEOMETRIC_ERROR: 'geometricError',\n  MAX_SCREEN_THRESHOLD: 'maxScreenThreshold'\n};\nconst TILE3D_OPTIMIZATION_HINT = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n\nfunction defined$3(x) {\n  return x !== undefined && x !== null;\n}\n\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\nfunction createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert$7(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n\n  if (boundingVolumeHeader.region) {\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin = [];\n\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n\n  if (defined$3(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\nfunction createSphere(sphere, transform, result) {\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined$3(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n\nnew Vector3();\nnew Vector3();\nnew Matrix4();\nnew Vector3();\nnew Vector3();\nnew Vector3();\nfunction fog(distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\nfunction getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {\n    const density = tileset.dynamicScreenSpaceErrorComputedDensity;\n    const factor = tileset.dynamicScreenSpaceErrorFactor;\n    const dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n\n  return 0;\n}\nfunction getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  const tileset = tile.tileset;\n  const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;\n  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n\n  const distance = Math.max(tile._distanceToCamera, 1e-7);\n  const {\n    height,\n    sseDenominator\n  } = frameState;\n  const {\n    viewDistanceScale\n  } = tileset.options;\n  let error = lodMetricValue * height * (viewDistanceScale || 1.0) / (distance * sseDenominator);\n  error -= getDynamicScreenSpaceError(tileset, distance);\n  return error;\n}\n\nfunction getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\nfunction getProjectedRadius(tile, frameState) {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom\n  } = originalViewport;\n  const viewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  const extraZ = projection * projection / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian).subtract(mbsCenterCartesian).normalize();\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}\n\nfunction get3dTilesOptions(tileset) {\n  return {\n    assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || 'Y'\n  };\n}\n\nclass ManagedArray {\n  constructor(length = 0) {\n    _defineProperty(this, \"_map\", new Map());\n\n    _defineProperty(this, \"_array\", void 0);\n\n    _defineProperty(this, \"_length\", void 0);\n\n    this._array = new Array(length);\n    this._length = length;\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  set length(length) {\n    this._length = length;\n\n    if (length > this._array.length) {\n      this._array.length = length;\n    }\n  }\n\n  get values() {\n    return this._array;\n  }\n\n  get(index) {\n    assert$7(index < this._array.length);\n    return this._array[index];\n  }\n\n  set(index, element) {\n    assert$7(index >= 0);\n\n    if (index >= this.length) {\n      this.length = index + 1;\n    }\n\n    if (this._map.has(this._array[index])) {\n      this._map.delete(this._array[index]);\n    }\n\n    this._array[index] = element;\n\n    this._map.set(element, index);\n  }\n\n  delete(element) {\n    const index = this._map.get(element);\n\n    if (index >= 0) {\n      this._array.splice(index, 1);\n\n      this._map.delete(element);\n\n      this.length--;\n    }\n  }\n\n  peek() {\n    return this._array[this._length - 1];\n  }\n\n  push(element) {\n    if (!this._map.has(element)) {\n      const index = this.length++;\n      this._array[index] = element;\n\n      this._map.set(element, index);\n    }\n  }\n\n  pop() {\n    const element = this._array[--this.length];\n\n    this._map.delete(element);\n\n    return element;\n  }\n\n  reserve(length) {\n    assert$7(length >= 0);\n\n    if (length > this._array.length) {\n      this._array.length = length;\n    }\n  }\n\n  resize(length) {\n    assert$7(length >= 0);\n    this.length = length;\n  }\n\n  trim(length) {\n    if (length === null || length === undefined) {\n      length = this.length;\n    }\n\n    this._array.length = length;\n  }\n\n  reset() {\n    this._array = [];\n    this._map = new Map();\n    this._length = 0;\n  }\n\n  find(target) {\n    return this._map.has(target);\n  }\n\n}\n\nconst DEFAULT_PROPS$1 = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nclass TilesetTraverser {\n  constructor(options) {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"requestedTiles\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"emptyTiles\", void 0);\n\n    _defineProperty(this, \"_traversalStack\", void 0);\n\n    _defineProperty(this, \"_emptyTraversalStack\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    this.options = { ...DEFAULT_PROPS$1,\n      ...options\n    };\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n\n  traverse(root, frameState, options) {\n    this.root = root;\n    this.options = { ...this.options,\n      ...options\n    };\n    this.reset();\n    this.updateTile(root, frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n\n    this._traversalStack.reset();\n\n    this._emptyTraversalStack.reset();\n  }\n\n  executeTraversal(root, frameState) {\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n    stack.push(root);\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      let shouldRefine = false;\n\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n      }\n\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      this.touchTile(tile, frameState);\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    this.options.onTraversalEnd(frameState);\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n\n    return true;\n  }\n\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {\n      loadSiblings,\n      skipLevelOfDetail\n    } = this.options;\n    const children = tile.children;\n    children.sort(this.compareDistanceToCamera.bind(this));\n    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n\n    return refines;\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    if (tile.hasTilesetContent) {\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds = [];\n\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n\n    return anyVisible;\n  }\n\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n\n        for (const child of children) {\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n\n}\n\nconst scratchVector = new Vector3();\n\nfunction defined$2(x) {\n  return x !== undefined && x !== null;\n}\n\nclass TileHeader {\n  constructor(tileset, header, parentHeader, extendedId = '') {\n    _defineProperty(this, \"tileset\", void 0);\n\n    _defineProperty(this, \"header\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"refine\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"contentUrl\", void 0);\n\n    _defineProperty(this, \"lodMetricType\", void 0);\n\n    _defineProperty(this, \"lodMetricValue\", void 0);\n\n    _defineProperty(this, \"boundingVolume\", void 0);\n\n    _defineProperty(this, \"content\", void 0);\n\n    _defineProperty(this, \"contentState\", void 0);\n\n    _defineProperty(this, \"gpuMemoryUsageInBytes\", void 0);\n\n    _defineProperty(this, \"children\", void 0);\n\n    _defineProperty(this, \"depth\", void 0);\n\n    _defineProperty(this, \"viewportIds\", void 0);\n\n    _defineProperty(this, \"transform\", void 0);\n\n    _defineProperty(this, \"extensions\", void 0);\n\n    _defineProperty(this, \"userData\", void 0);\n\n    _defineProperty(this, \"computedTransform\", void 0);\n\n    _defineProperty(this, \"hasEmptyContent\", void 0);\n\n    _defineProperty(this, \"hasTilesetContent\", void 0);\n\n    _defineProperty(this, \"traverser\", void 0);\n\n    _defineProperty(this, \"_cacheNode\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_lodJudge\", void 0);\n\n    _defineProperty(this, \"_expireDate\", void 0);\n\n    _defineProperty(this, \"_expiredContent\", void 0);\n\n    _defineProperty(this, \"_shouldRefine\", void 0);\n\n    _defineProperty(this, \"_distanceToCamera\", void 0);\n\n    _defineProperty(this, \"_centerZDepth\", void 0);\n\n    _defineProperty(this, \"_screenSpaceError\", void 0);\n\n    _defineProperty(this, \"_visibilityPlaneMask\", void 0);\n\n    _defineProperty(this, \"_visible\", void 0);\n\n    _defineProperty(this, \"_inRequestVolume\", void 0);\n\n    _defineProperty(this, \"_stackLength\", void 0);\n\n    _defineProperty(this, \"_selectionDepth\", void 0);\n\n    _defineProperty(this, \"_touchedFrame\", void 0);\n\n    _defineProperty(this, \"_visitedFrame\", void 0);\n\n    _defineProperty(this, \"_selectedFrame\", void 0);\n\n    _defineProperty(this, \"_requestedFrame\", void 0);\n\n    _defineProperty(this, \"_priority\", void 0);\n\n    _defineProperty(this, \"_contentBoundingVolume\", void 0);\n\n    _defineProperty(this, \"_viewerRequestVolume\", void 0);\n\n    _defineProperty(this, \"_initialTransform\", void 0);\n\n    this.header = header;\n    this.tileset = tileset;\n    this.id = extendedId || header.id;\n    this.url = header.url;\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n    this.lodMetricType = 'geometricError';\n    this.lodMetricValue = 0;\n    this.boundingVolume = null;\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n    this.children = [];\n    this.hasEmptyContent = false;\n    this.hasTilesetContent = false;\n    this.depth = 0;\n    this.viewportIds = [];\n    this.userData = {};\n    this.extensions = null;\n    this._priority = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._screenSpaceError = 0;\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n    this.traverser = new TilesetTraverser({});\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._initialTransform = new Matrix4();\n    this.transform = new Matrix4();\n\n    this._initializeLodMetric(header);\n\n    this._initializeTransforms(header);\n\n    this._initializeBoundingVolumes(header);\n\n    this._initializeContent(header);\n\n    this._initializeRenderingState(header);\n\n    this._lodJudge = null;\n    this._expireDate = null;\n    this._expiredContent = null;\n    Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n\n  get contentAvailable() {\n    return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getProjectedRadius(this, frameState);\n\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n\n      default:\n        throw new Error('Unsupported tileset type');\n    }\n  }\n\n  _getPriority() {\n    const traverser = this.tileset._traverser;\n    const {\n      skipLevelOfDetail\n    } = traverser.options;\n    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n\n    if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n      return -1;\n    }\n\n    if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n      return -1;\n    }\n\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n\n    const parent = this.parent;\n    const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n    const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;\n    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n    return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n  }\n\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this.content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    if (expired) {\n      this._expireDate = null;\n    }\n\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n\n    if (!requestToken) {\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      const loader = this.tileset.loader;\n      const options = { ...this.tileset.loadOptions,\n        [loader.id]: { ...this.tileset.loadOptions[loader.id],\n          isTileset: this.type === 'json',\n          ...this._getLoaderSpecificOptions(loader.id)\n        }\n      };\n      this.content = await load(contentUrl, loader, options);\n\n      if (this.tileset.options.contentLoader) {\n        await this.tileset.options.contentLoader(this);\n      }\n\n      if (this._isTileset()) {\n        this.tileset._initializeTileHeaders(this.content, this);\n      }\n\n      this.contentState = TILE_CONTENT_STATE.READY;\n\n      this._onContentLoaded();\n\n      return true;\n    } catch (error) {\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n\n    this.content = null;\n\n    if (this.header.content && this.header.content.destroy) {\n      this.header.content.destroy();\n    }\n\n    this.header.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  updateVisibility(frameState, viewportIds) {\n    if (this._frameNumber === frameState.frameNumber) {\n      return;\n    }\n\n    const parent = this.parent;\n    const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n\n      this._updateTransform(parentTransform);\n    }\n\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.viewportIds = viewportIds;\n  }\n\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {\n      cullingVolume\n    } = frameState;\n    const {\n      boundingVolume\n    } = this;\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  contentVisibility() {\n    return true;\n  }\n\n  distanceToTile(frameState) {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  cameraSpaceZDepth({\n    camera\n  }) {\n    const boundingVolume = this.boundingVolume;\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;\n  }\n\n  updateExpiration() {\n    if (defined$2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;\n      console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\");\n    }\n\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;\n      console.warn('3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue');\n    }\n  }\n\n  _initializeTransforms(tileHeader) {\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n    const parent = this.parent;\n    const tileset = this.tileset;\n    const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n    const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    this._updateBoundingVolume(tileHeader);\n  }\n\n  _initializeContent(tileHeader) {\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    };\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.hasTilesetContent = false;\n\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n\n  _initializeRenderingState(header) {\n    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        this.tileset._traverser.disableSkipLevelOfDetail = true;\n        break;\n    }\n\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  _updateBoundingVolume(header) {\n    this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n    const content = header.content;\n\n    if (!content) {\n      return;\n    }\n\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n    }\n\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n    }\n  }\n\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    this._updateBoundingVolume(this.header);\n  }\n\n  _getLoaderSpecificOptions(loaderId) {\n    switch (loaderId) {\n      case 'i3s':\n        return { ...this.tileset.options.i3s,\n          tile: this.header,\n          tileset: this.tileset.tileset,\n          isTileHeader: false\n        };\n\n      case '3d-tiles':\n      case 'cesium-ion':\n      default:\n        return get3dTilesOptions(this.tileset.tileset);\n    }\n  }\n\n}\n\nclass Tileset3DTraverser extends TilesetTraverser {\n  compareDistanceToCamera(a, b) {\n    return b._distanceToCamera === 0 && a._distanceToCamera === 0 ? b._centerZDepth - a._centerZDepth : b._distanceToCamera - a._distanceToCamera;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    super.updateTileVisibility(tile, frameState);\n\n    if (!tile.isVisibleAndInRequestVolume) {\n      return;\n    }\n\n    const hasChildren = tile.children.length > 0;\n\n    if (tile.hasTilesetContent && hasChildren) {\n      const firstChild = tile.children[0];\n      this.updateTileVisibility(firstChild, frameState);\n      tile._visible = firstChild._visible;\n      return;\n    }\n\n    if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {\n      tile._visible = false;\n      return;\n    }\n\n    const replace = tile.refine === TILE_REFINEMENT.REPLACE;\n    const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;\n\n    if (replace && useOptimization && hasChildren) {\n      if (!this.anyChildrenVisible(tile, frameState)) {\n        tile._visible = false;\n        return;\n      }\n    }\n  }\n\n  meetsScreenSpaceErrorEarly(tile, frameState) {\n    const {\n      parent\n    } = tile;\n\n    if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {\n      return false;\n    }\n\n    return !this.shouldRefine(tile, frameState, true);\n  }\n\n}\n\nconst STATUS = {\n  REQUESTED: 'REQUESTED',\n  COMPLETED: 'COMPLETED',\n  ERROR: 'ERROR'\n};\nclass I3STileManager {\n  constructor() {\n    _defineProperty(this, \"_statusMap\", void 0);\n\n    this._statusMap = {};\n  }\n\n  add(request, key, callback, frameState) {\n    if (!this._statusMap[key]) {\n      this._statusMap[key] = {\n        request,\n        callback,\n        key,\n        frameState,\n        status: STATUS.REQUESTED\n      };\n      request().then(data => {\n        this._statusMap[key].status = STATUS.COMPLETED;\n\n        this._statusMap[key].callback(data, frameState);\n      }).catch(error => {\n        this._statusMap[key].status = STATUS.ERROR;\n        callback(error);\n      });\n    }\n  }\n\n  update(key, frameState) {\n    if (this._statusMap[key]) {\n      this._statusMap[key].frameState = frameState;\n    }\n  }\n\n  find(key) {\n    return this._statusMap[key];\n  }\n\n}\n\nclass I3STilesetTraverser extends TilesetTraverser {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"_tileManager\", void 0);\n\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = \"\".concat(child.id, \"-\").concat(frameState.viewport.id);\n      const childTile = childTiles && childTiles.find(t => t.id === extendedId);\n\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n\n        const cachedRequest = this._tileManager.find(extendedId);\n\n        if (!cachedRequest) {\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n\n          this._tileManager.add(request, extendedId, header => this._onTileLoad(header, tile, extendedId), frameState);\n        } else {\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        this.updateTile(childTile, frameState);\n      }\n    }\n\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {\n      loader\n    } = tileset;\n    const nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n    const options = { ...tileset.loadOptions,\n      i3s: { ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n\n  _onTileLoad(header, tile, extendedId) {\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n\n    const frameState = this._tileManager.find(childTile.id).frameState;\n\n    this.updateTile(childTile, frameState);\n\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n\n}\n\nconst DEFAULT_PROPS = {\n  description: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: true,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: selectedTiles => selectedTiles,\n  contentLoader: undefined,\n  viewDistanceScale: 1.0,\n  maximumScreenSpaceError: 8,\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: '',\n  i3s: {}\n};\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nclass Tileset3D {\n  constructor(json, options) {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"loadOptions\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"tileset\", void 0);\n\n    _defineProperty(this, \"loader\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"basePath\", void 0);\n\n    _defineProperty(this, \"modelMatrix\", void 0);\n\n    _defineProperty(this, \"ellipsoid\", void 0);\n\n    _defineProperty(this, \"lodMetricType\", void 0);\n\n    _defineProperty(this, \"lodMetricValue\", void 0);\n\n    _defineProperty(this, \"refine\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"roots\", void 0);\n\n    _defineProperty(this, \"asset\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extras\", void 0);\n\n    _defineProperty(this, \"attributions\", void 0);\n\n    _defineProperty(this, \"credits\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"traverseCounter\", void 0);\n\n    _defineProperty(this, \"geometricError\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"cartographicCenter\", void 0);\n\n    _defineProperty(this, \"cartesianCenter\", void 0);\n\n    _defineProperty(this, \"zoom\", void 0);\n\n    _defineProperty(this, \"boundingVolume\", void 0);\n\n    _defineProperty(this, \"gpuMemoryUsageInBytes\", void 0);\n\n    _defineProperty(this, \"dynamicScreenSpaceErrorComputedDensity\", void 0);\n\n    _defineProperty(this, \"_traverser\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    _defineProperty(this, \"_requestScheduler\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_queryParamsString\", void 0);\n\n    _defineProperty(this, \"_queryParams\", void 0);\n\n    _defineProperty(this, \"_extensionsUsed\", void 0);\n\n    _defineProperty(this, \"_tiles\", void 0);\n\n    _defineProperty(this, \"_pendingCount\", void 0);\n\n    _defineProperty(this, \"lastUpdatedVieports\", void 0);\n\n    _defineProperty(this, \"_requestedTiles\", void 0);\n\n    _defineProperty(this, \"_emptyTiles\", void 0);\n\n    _defineProperty(this, \"frameStateData\", void 0);\n\n    _defineProperty(this, \"maximumMemoryUsage\", void 0);\n\n    assert$7(json);\n    this.options = { ...DEFAULT_PROPS,\n      ...options\n    };\n    this.tileset = json;\n    this.loader = json.loader;\n    this.type = json.type;\n    this.url = json.url;\n    this.basePath = json.basePath || dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n    this.loadOptions = this.options.loadOptions || {};\n    this.root = null;\n    this.roots = {};\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    this._frameNumber = 0;\n    this._pendingCount = 0;\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n    this._queryParams = {};\n    this._queryParamsString = '';\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({\n      id: this.url\n    });\n\n    this._initializeStats();\n\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0;\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n\n    this._initializeTileSet(json);\n  }\n\n  destroy() {\n    this._destroy();\n  }\n\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0;\n  }\n\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber() {\n    return this._frameNumber;\n  }\n\n  get queryParams() {\n    if (!this._queryParamsString) {\n      this._queryParamsString = getQueryParamString(this._queryParams);\n    }\n\n    return this._queryParamsString;\n  }\n\n  setProps(props) {\n    this.options = { ...this.options,\n      ...props\n    };\n  }\n\n  setOptions(options) {\n    this.options = { ...this.options,\n      ...options\n    };\n  }\n\n  getTileUrl(tilePath) {\n    const isDataUrl = tilePath.startsWith('data:');\n\n    if (isDataUrl) {\n      return tilePath;\n    }\n\n    return \"\".concat(tilePath).concat(this.queryParams);\n  }\n\n  hasExtension(extensionName) {\n    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n\n  update(viewports) {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    if (!viewports && this.lastUpdatedVieports) {\n      viewports = this.lastUpdatedVieports;\n    } else {\n      this.lastUpdatedVieports = viewports;\n    }\n\n    if (!(viewports instanceof Array)) {\n      viewports = [viewports];\n    }\n\n    this._cache.reset();\n\n    this._frameNumber++;\n    this.traverseCounter = viewports.length;\n    const viewportsToTraverse = [];\n\n    for (const viewport of viewports) {\n      const id = viewport.id;\n\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n\n    for (const viewport of viewports) {\n      const id = viewport.id;\n\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n\n      if (!viewportsToTraverse.includes(id)) {\n        continue;\n      }\n\n      const frameState = getFrameState(viewport, this._frameNumber);\n\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n\n  _needTraverse(viewportId) {\n    let traverserId = viewportId;\n\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n\n    if (traverserId !== viewportId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _onTraversalEnd(frameState) {\n    const id = frameState.viewport.id;\n\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {\n        selectedTiles: [],\n        _requestedTiles: [],\n        _emptyTiles: []\n      };\n    }\n\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    currentFrameStateData.selectedTiles = selectedTiles;\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n    this.traverseCounter--;\n\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    this._updateTiles();\n  }\n\n  _updateTiles() {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n\n    this._loadTiles();\n\n    this._unloadTiles();\n\n    this._updateStats();\n  }\n\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n\n    const set1 = new Set(oldSelectedTiles.map(t => t.id));\n    const set2 = new Set(selectedTiles.map(t => t.id));\n    let changed = oldSelectedTiles.filter(x => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter(x => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n\n  _loadTiles() {\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        this._loadTile(tile);\n      }\n    }\n  }\n\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        }\n      }\n    }\n\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n  }\n\n  _initializeTileSet(tilesetJson) {\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeCesiumTileset(tilesetJson);\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n\n    this._calculateViewProps();\n  }\n\n  _calculateViewProps() {\n    const root = this.root;\n    assert$7(root);\n    const {\n      center\n    } = root.boundingVolume;\n\n    if (!center) {\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n\n    this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume);\n  }\n\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT, 'memory');\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n  }\n\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    const rootTile = new TileHeader(this, tilesetJson.root, parentTileHeader);\n\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        const tile = stack.pop();\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n\n        for (const childHeader of children) {\n          const childTile = new TileHeader(this, childHeader, tile);\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n\n    return rootTile;\n  }\n\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3STilesetTraverser;\n        break;\n\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n\n  async _loadTile(tile) {\n    let loaded;\n\n    try {\n      this._onStartTileLoading();\n\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error);\n    } finally {\n      this._onEndTileLoading();\n\n      this._onTileLoad(tile, loaded);\n    }\n  }\n\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n    const message = error.message || error.toString();\n    const url = tile.url;\n    console.error(\"A 3D tile failed to load: \".concat(tile.url, \" \").concat(message));\n    this.options.onTileError(tile, message, url);\n  }\n\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n\n    this._addTileToCache(tile);\n\n    this.options.onTileLoad(tile);\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, tileset => tileset._updateCacheStats(tile));\n  }\n\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n    this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n  }\n\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= tile.content && tile.content.byteLength || 0;\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n\n  _destroy() {\n    const stack = [];\n\n    if (this.root) {\n      stack.push(this.root);\n    }\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      this._destroyTile(tile);\n    }\n\n    this.root = null;\n  }\n\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack = [];\n    stack.push(root);\n\n    while (stack.length > 0) {\n      tile = stack.pop();\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n\n    root.children = [];\n  }\n\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n\n    this._unloadTile(tile);\n\n    tile.destroy();\n  }\n\n  _initializeCesiumTileset(tilesetJson) {\n    this.asset = tilesetJson.asset;\n\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n    }\n\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed;\n    this.extras = tilesetJson.extras;\n  }\n\n  _initializeI3STileset() {\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n\n}\n\nfunction getQueryParamString(queryParams) {\n  const queryParamStrings = [];\n\n  for (const key of Object.keys(queryParams)) {\n    queryParamStrings.push(\"\".concat(key, \"=\").concat(queryParams[key]));\n  }\n\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n\n    case 1:\n      return \"?\".concat(queryParamStrings[0]);\n\n    default:\n      return \"?\".concat(queryParamStrings.join('&'));\n  }\n}\n\nconst VERSION$5 = \"3.1.4\" ;\n\nconst TILE3D_TYPE = {\n  COMPOSITE: 'cmpt',\n  POINT_CLOUD: 'pnts',\n  BATCHED_3D_MODEL: 'b3dm',\n  INSTANCED_3D_MODEL: 'i3dm',\n  GEOMETRY: 'geom',\n  VECTOR: 'vect',\n  GLTF: 'glTF'\n};\n\nfunction getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  assert$7(arrayBuffer instanceof ArrayBuffer);\n  const textDecoder = new TextDecoder('utf8');\n  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n  const string = textDecoder.decode(typedArray);\n  return string;\n}\nfunction getMagicString$1(arrayBuffer, byteOffset = 0) {\n  const dataView = new DataView(arrayBuffer);\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nconst VERSION$4 = \"3.1.4\" ;\n\nconst DEFAULT_DRACO_OPTIONS = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js',\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\nconst DracoLoader$1 = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  shapes: ['mesh'],\n  version: VERSION$4,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nfunction getMeshBoundingBox(attributes) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n\n  return [[minX, minY, minZ], [maxX, maxY, maxZ]];\n}\n\nfunction assert$3(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n\nclass Schema {\n  constructor(fields, metadata) {\n    _defineProperty(this, \"fields\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    assert$3(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  select(...columnNames) {\n    const nameMap = Object.create(null);\n\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices) {\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    const fieldMap = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n    return new Schema(mergedFields, metadata);\n  }\n\n}\n\nfunction checkNames(fields) {\n  const usedNames = {};\n\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\nclass Field {\n  constructor(name, type, nullable = false, metadata = new Map()) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"nullable\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId() {\n    return this.type && this.type.typeId;\n  }\n\n  clone() {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other) {\n    return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;\n  }\n\n  toString() {\n    return \"\".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? \", metadata: \".concat(this.metadata) : '');\n  }\n\n}\n\nlet Type;\n\n(function (Type) {\n  Type[Type[\"NONE\"] = 0] = \"NONE\";\n  Type[Type[\"Null\"] = 1] = \"Null\";\n  Type[Type[\"Int\"] = 2] = \"Int\";\n  Type[Type[\"Float\"] = 3] = \"Float\";\n  Type[Type[\"Binary\"] = 4] = \"Binary\";\n  Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n  Type[Type[\"Bool\"] = 6] = \"Bool\";\n  Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n  Type[Type[\"Date\"] = 8] = \"Date\";\n  Type[Type[\"Time\"] = 9] = \"Time\";\n  Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type[Type[\"Interval\"] = 11] = \"Interval\";\n  Type[Type[\"List\"] = 12] = \"List\";\n  Type[Type[\"Struct\"] = 13] = \"Struct\";\n  Type[Type[\"Union\"] = 14] = \"Union\";\n  Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type[Type[\"Map\"] = 17] = \"Map\";\n  Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type[Type[\"Int8\"] = -2] = \"Int8\";\n  Type[Type[\"Int16\"] = -3] = \"Int16\";\n  Type[Type[\"Int32\"] = -4] = \"Int32\";\n  Type[Type[\"Int64\"] = -5] = \"Int64\";\n  Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n  Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n  Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n  Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n  Type[Type[\"Float16\"] = -10] = \"Float16\";\n  Type[Type[\"Float32\"] = -11] = \"Float32\";\n  Type[Type[\"Float64\"] = -12] = \"Float64\";\n  Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n  Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\n\nlet _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag7;\nclass DataType {\n  static isNull(x) {\n    return x && x.typeId === Type.Null;\n  }\n\n  static isInt(x) {\n    return x && x.typeId === Type.Int;\n  }\n\n  static isFloat(x) {\n    return x && x.typeId === Type.Float;\n  }\n\n  static isBinary(x) {\n    return x && x.typeId === Type.Binary;\n  }\n\n  static isUtf8(x) {\n    return x && x.typeId === Type.Utf8;\n  }\n\n  static isBool(x) {\n    return x && x.typeId === Type.Bool;\n  }\n\n  static isDecimal(x) {\n    return x && x.typeId === Type.Decimal;\n  }\n\n  static isDate(x) {\n    return x && x.typeId === Type.Date;\n  }\n\n  static isTime(x) {\n    return x && x.typeId === Type.Time;\n  }\n\n  static isTimestamp(x) {\n    return x && x.typeId === Type.Timestamp;\n  }\n\n  static isInterval(x) {\n    return x && x.typeId === Type.Interval;\n  }\n\n  static isList(x) {\n    return x && x.typeId === Type.List;\n  }\n\n  static isStruct(x) {\n    return x && x.typeId === Type.Struct;\n  }\n\n  static isUnion(x) {\n    return x && x.typeId === Type.Union;\n  }\n\n  static isFixedSizeBinary(x) {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n\n  static isFixedSizeList(x) {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n\n  static isMap(x) {\n    return x && x.typeId === Type.Map;\n  }\n\n  static isDictionary(x) {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId() {\n    return Type.NONE;\n  }\n\n  compareTo(other) {\n    return this === other;\n  }\n\n}\n_Symbol$toStringTag = Symbol.toStringTag;\nclass Int extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n\n    _defineProperty(this, \"isSigned\", void 0);\n\n    _defineProperty(this, \"bitWidth\", void 0);\n\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n\n  get typeId() {\n    return Type.Int;\n  }\n\n  get [_Symbol$toStringTag]() {\n    return 'Int';\n  }\n\n  toString() {\n    return \"\".concat(this.isSigned ? 'I' : 'Ui', \"nt\").concat(this.bitWidth);\n  }\n\n}\nclass Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n\n}\nclass Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n\n}\nclass Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n\n}\nclass Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n\n}\nclass Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n\n}\nclass Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n\n}\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass Float extends DataType {\n  constructor(precision) {\n    super();\n\n    _defineProperty(this, \"precision\", void 0);\n\n    this.precision = precision;\n  }\n\n  get typeId() {\n    return Type.Float;\n  }\n\n  get [_Symbol$toStringTag2]() {\n    return 'Float';\n  }\n\n  toString() {\n    return \"Float\".concat(this.precision);\n  }\n\n}\nclass Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n\n}\nclass Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n\n}\n_Symbol$toStringTag7 = Symbol.toStringTag;\nclass FixedSizeList extends DataType {\n  constructor(listSize, child) {\n    super();\n\n    _defineProperty(this, \"listSize\", void 0);\n\n    _defineProperty(this, \"children\", void 0);\n\n    this.listSize = listSize;\n    this.children = [child];\n  }\n\n  get typeId() {\n    return Type.FixedSizeList;\n  }\n\n  get valueType() {\n    return this.children[0].type;\n  }\n\n  get valueField() {\n    return this.children[0];\n  }\n\n  get [_Symbol$toStringTag7]() {\n    return 'FixedSizeList';\n  }\n\n  toString() {\n    return \"FixedSizeList[\".concat(this.listSize, \"]<\").concat(this.valueType, \">\");\n  }\n\n}\n\nfunction getArrowTypeFromTypedArray(array) {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n\n    case Uint8Array:\n      return new Uint8();\n\n    case Int16Array:\n      return new Int16();\n\n    case Uint16Array:\n      return new Uint16();\n\n    case Int32Array:\n      return new Int32();\n\n    case Uint32Array:\n      return new Uint32();\n\n    case Float32Array:\n      return new Float32();\n\n    case Float64Array:\n      return new Float64();\n\n    default:\n      throw new Error('array type not supported');\n  }\n}\n\nfunction deduceMeshField(attributeName, attribute, optionalMetadata) {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field('value', type)), false, metadata);\n  return field;\n}\n\nfunction makeMeshAttributeMetadata(attribute) {\n  const result = new Map();\n\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset.toString(10));\n  }\n\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride.toString(10));\n  }\n\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized.toString());\n  }\n\n  return result;\n}\n\nfunction getDracoSchema(attributes, loaderData, indices) {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n    fields.push(field);\n  }\n\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData) {\n  const result = {};\n\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata) {\n  const metadataMap = new Map();\n\n  for (const key in metadata) {\n    metadataMap.set(\"\".concat(key, \".string\"), JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\nconst INDEX_ITEM_SIZE = 4;\nclass DracoParser {\n  constructor(draco) {\n    _defineProperty(this, \"draco\", void 0);\n\n    _defineProperty(this, \"decoder\", void 0);\n\n    _defineProperty(this, \"metadataQuerier\", void 0);\n\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  destroy() {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  parseSync(arrayBuffer, options = {}) {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n      const data = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  _getDracoAttributes(dracoGeometry, options) {\n    const dracoAttributes = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n        metadata\n      };\n\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  _getMeshData(dracoGeometry, loaderData, options) {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4,\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5,\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    return {\n      topology: 'point-list',\n      mode: 0,\n      attributes\n    };\n  }\n\n  _getMeshAttributes(loaderData, dracoGeometry, options) {\n    const attributes = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n\n      loaderAttribute.name = attributeName;\n\n      const {\n        value,\n        size\n      } = this._getAttributeValues(dracoGeometry, loaderAttribute);\n\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  _getTriangleListIndices(dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  _getTriangleStripIndices(dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n\n    try {\n      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _getAttributeValues(dracoGeometry, attribute) {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n    let value;\n\n    const ptr = this.draco._malloc(byteLength);\n\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {\n      value,\n      size: numComponents\n    };\n  }\n\n  _deduceAttributeName(attribute, options) {\n    const uniqueId = attribute.unique_id;\n\n    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    const thisAttributeType = attribute.attribute_type;\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n\n      if (attributeType === thisAttributeType) {\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    const entryName = options.attributeNameEntry || 'name';\n\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    return \"CUSTOM_ATTRIBUTE_\".concat(uniqueId);\n  }\n\n  _getTopLevelMetadata(dracoGeometry) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(dracoGeometry, attributeId) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n\n    return result;\n  }\n\n  _getDracoMetadataField(dracoMetadata, entryName) {\n    const dracoArray = new this.draco.DracoInt32Array();\n\n    try {\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _disableAttributeTransforms(options) {\n    const {\n      quantizedAttributes = [],\n      octahedronAttributes = []\n    } = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  _getQuantizationTransform(dracoAttribute, options) {\n    const {\n      quantizedAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map(type => this.decoder[type]).includes(attribute_type);\n\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map(i => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n\n    return null;\n  }\n\n  _getOctahedronTransform(dracoAttribute, options) {\n    const {\n      octahedronAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes.map(type => this.decoder[type]).includes(attribute_type);\n\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction getDracoDataType(draco, attributeType) {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n\n    case Int8Array:\n      return draco.DT_INT8;\n\n    case Int16Array:\n      return draco.DT_INT16;\n\n    case Int32Array:\n      return draco.DT_INT32;\n\n    case Uint8Array:\n      return draco.DT_UINT8;\n\n    case Uint16Array:\n      return draco.DT_UINT16;\n\n    case Uint32Array:\n      return draco.DT_UINT32;\n\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\nfunction getInt32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n\n  return intArray;\n}\n\nfunction getUint32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n\n  return intArray;\n}\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_decoder.js\");\nconst DRACO_WASM_WRAPPER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_wasm_wrapper.js\");\nconst DRACO_WASM_DECODER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_VERSION, \"/draco_decoder.wasm\");\nlet loadDecoderPromise;\nasync function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.draco3d) {\n    loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n\n  return await loadDecoderPromise;\n}\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options), await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)]);\n  }\n\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise(resolve => {\n    DracoDecoderModule({ ...options,\n      onModuleLoaded: draco => resolve({\n        draco\n      })\n    });\n  });\n}\n\nconst DracoLoader = { ...DracoLoader$1,\n  parse: parse$2\n};\n\nasync function parse$2(arrayBuffer, options) {\n  const {\n    draco\n  } = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n\n  try {\n    return dracoParser.parseSync(arrayBuffer, options === null || options === void 0 ? void 0 : options.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\nconst GL_PRIMITIVE_MODE = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006\n};\nconst GL_TYPE = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n};\nconst GL$1 = { ...GL_PRIMITIVE_MODE,\n  ...GL_TYPE\n};\n\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL_TYPE.DOUBLE]: Float64Array,\n  [GL_TYPE.FLOAT]: Float32Array,\n  [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,\n  [GL_TYPE.UNSIGNED_INT]: Uint32Array,\n  [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,\n  [GL_TYPE.BYTE]: Int8Array,\n  [GL_TYPE.SHORT]: Int16Array,\n  [GL_TYPE.INT]: Int32Array\n};\nconst NAME_TO_GL_TYPE = {\n  DOUBLE: GL_TYPE.DOUBLE,\n  FLOAT: GL_TYPE.FLOAT,\n  UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,\n  BYTE: GL_TYPE.BYTE,\n  SHORT: GL_TYPE.SHORT,\n  INT: GL_TYPE.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\nclass GLType {\n  static fromTypedArray(arrayOrType) {\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n\n  static fromName(name) {\n    const glType = NAME_TO_GL_TYPE[name];\n\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n\n    return glType;\n  }\n\n  static getArrayType(glType) {\n    switch (glType) {\n      case GL_TYPE.UNSIGNED_SHORT_5_6_5:\n      case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:\n      case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n\n        return ArrayType;\n    }\n  }\n\n  static getByteSize(glType) {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  static validate(glType) {\n    return Boolean(GLType.getArrayType(glType));\n  }\n\n  static createTypedArray(glType, buffer, byteOffset = 0, length) {\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n\n}\n\nfunction assert$2(condition, message) {\n  if (!condition) {\n    throw new Error(\"math.gl assertion failed. \".concat(message));\n  }\n}\n\nfunction decodeRGB565(rgb565, target = [0, 0, 0]) {\n  const r5 = rgb565 >> 11 & 31;\n  const g6 = rgb565 >> 5 & 63;\n  const b5 = rgb565 & 31;\n  target[0] = r5 << 3;\n  target[1] = g6 << 2;\n  target[2] = b5 << 3;\n  return target;\n}\n\nnew Vector2();\nnew Vector3();\nnew Vector2();\nnew Vector2();\n\nfunction fromSNorm(value, rangeMaximum = 255) {\n  return clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n}\n\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\nfunction octDecodeInRange(x, y, rangeMax, result) {\n  assert$2(result);\n\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(\"x and y must be unsigned normalized integers between 0 and \".concat(rangeMax));\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\nfunction octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\n\nclass Tile3DFeatureTable {\n  constructor(featureTableJson, featureTableBinary) {\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"buffer\", void 0);\n\n    _defineProperty(this, \"featuresLength\", 0);\n\n    _defineProperty(this, \"_cachedTypedArrays\", {});\n\n    this.json = featureTableJson;\n    this.buffer = featureTableBinary;\n  }\n\n  getExtension(extensionName) {\n    return this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  hasProperty(propertyName) {\n    return Boolean(this.json[propertyName]);\n  }\n\n  getGlobalProperty(propertyName, componentType = GL$1.UNSIGNED_INT, componentLength = 1) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);\n    }\n\n    return jsonValue;\n  }\n\n  getPropertyArray(propertyName, componentType, componentLength) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      if ('componentType' in jsonValue) {\n        componentType = GLType.fromName(jsonValue.componentType);\n      }\n\n      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);\n    }\n\n    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n  }\n\n  getProperty(propertyName, componentType, componentLength, featureId, result) {\n    const jsonValue = this.json[propertyName];\n\n    if (!jsonValue) {\n      return jsonValue;\n    }\n\n    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n\n    if (componentLength === 1) {\n      return typedArray[featureId];\n    }\n\n    for (let i = 0; i < componentLength; ++i) {\n      result[i] = typedArray[componentLength * featureId + i];\n    }\n\n    return result;\n  }\n\n  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n\n    return typedArray;\n  }\n\n  _getTypedArrayFromArray(propertyName, componentType, array) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, array);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n\n    return typedArray;\n  }\n\n}\n\nconst COMPONENTS_PER_ATTRIBUTE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst UNPACKER = {\n  SCALAR: (values, i) => values[i],\n  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],\n  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],\n  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],\n  MAT2: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],\n  MAT3: (values, i) => [values[9 * i + 0], values[9 * i + 1], values[9 * i + 2], values[9 * i + 3], values[9 * i + 4], values[9 * i + 5], values[9 * i + 6], values[9 * i + 7], values[9 * i + 8]],\n  MAT4: (values, i) => [values[16 * i + 0], values[16 * i + 1], values[16 * i + 2], values[16 * i + 3], values[16 * i + 4], values[16 * i + 5], values[16 * i + 6], values[16 * i + 7], values[16 * i + 8], values[16 * i + 9], values[16 * i + 10], values[16 * i + 11], values[16 * i + 12], values[16 * i + 13], values[16 * i + 14], values[16 * i + 15]]\n};\nconst PACKER = {\n  SCALAR: (x, values, i) => {\n    values[i] = x;\n  },\n  VEC2: (x, values, i) => {\n    values[2 * i + 0] = x[0];\n    values[2 * i + 1] = x[1];\n  },\n  VEC3: (x, values, i) => {\n    values[3 * i + 0] = x[0];\n    values[3 * i + 1] = x[1];\n    values[3 * i + 2] = x[2];\n  },\n  VEC4: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  MAT2: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  MAT3: (x, values, i) => {\n    values[9 * i + 0] = x[0];\n    values[9 * i + 1] = x[1];\n    values[9 * i + 2] = x[2];\n    values[9 * i + 3] = x[3];\n    values[9 * i + 4] = x[4];\n    values[9 * i + 5] = x[5];\n    values[9 * i + 6] = x[6];\n    values[9 * i + 7] = x[7];\n    values[9 * i + 8] = x[8];\n    values[9 * i + 9] = x[9];\n  },\n  MAT4: (x, values, i) => {\n    values[16 * i + 0] = x[0];\n    values[16 * i + 1] = x[1];\n    values[16 * i + 2] = x[2];\n    values[16 * i + 3] = x[3];\n    values[16 * i + 4] = x[4];\n    values[16 * i + 5] = x[5];\n    values[16 * i + 6] = x[6];\n    values[16 * i + 7] = x[7];\n    values[16 * i + 8] = x[8];\n    values[16 * i + 9] = x[9];\n    values[16 * i + 10] = x[10];\n    values[16 * i + 11] = x[11];\n    values[16 * i + 12] = x[12];\n    values[16 * i + 13] = x[13];\n    values[16 * i + 14] = x[14];\n    values[16 * i + 15] = x[15];\n  }\n};\nfunction createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {\n  const {\n    componentType\n  } = tile3DAccessor;\n  assert$7(tile3DAccessor.componentType);\n  const type = typeof componentType === 'string' ? GLType.fromName(componentType) : componentType;\n  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];\n  const unpacker = UNPACKER[tile3DAccessor.type];\n  const packer = PACKER[tile3DAccessor.type];\n  byteOffset += tile3DAccessor.byteOffset;\n  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length);\n  return {\n    values,\n    type,\n    size,\n    unpacker,\n    packer\n  };\n}\n\nconst defined$1 = x => x !== undefined;\n\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n\n  if (legacyHierarchy) {\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n\n  if (defined$1(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n  }\n\n  let parentIndexes;\n\n  if (defined$1(parentCounts)) {\n    if (defined$1(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n    }\n\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined$1(parentIds) && defined$1(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n  }\n\n  const classesLength = classes.length;\n\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n  validateHierarchy(hierarchy);\n  return hierarchy;\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n\n    if (visited[instanceIndex] === visitedMarker) {\n      continue;\n    }\n\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined$1(result)) {\n      return result;\n    }\n\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n\n    if (defined$1(result)) {\n      return result;\n    }\n\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n\n  throw new Error('traverseHierarchySingleParent');\n}\n\nfunction validateHierarchy(hierarchy) {\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined$1(parentIds)) {\n    return;\n  }\n\n  assert(instanceIndex < instancesLength, \"Parent index \".concat(instanceIndex, \" exceeds the total number of instances: \").concat(instancesLength));\n  assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n  stack.push(instanceIndex);\n  const parentCount = defined$1(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined$1(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n\n  stack.pop(instanceIndex);\n}\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  extensions: true,\n  extras: true\n};\nclass Tile3DBatchTableParser {\n  constructor(json, binary, featureCount, options = {}) {\n    var _this$json;\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"binary\", void 0);\n\n    _defineProperty(this, \"featureCount\", void 0);\n\n    _defineProperty(this, \"_extensions\", void 0);\n\n    _defineProperty(this, \"_properties\", void 0);\n\n    _defineProperty(this, \"_binaryProperties\", void 0);\n\n    _defineProperty(this, \"_hierarchy\", void 0);\n\n    assert$7(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};\n    this._properties = {};\n\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n\n    assert$7(typeof className === 'string', className);\n\n    if (this._hierarchy) {\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert$7(typeof className === 'string', className);\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert$7(typeof name === 'string', name);\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert$7(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId]);\n    }\n\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n\n    assert$7(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n\n        return;\n      }\n    }\n\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n\n    if (!defined(propertyValues)) {\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value);\n  }\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n\n    for (const name in this._properties) {\n      const property = this._properties[name];\n\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      const tile3DAccessor = property;\n      assert$7(this.binary, \"Property \".concat(name, \" requires a batch table binary.\"));\n      assert$7(tile3DAccessor.type, \"Property \".concat(name, \" requires a type.\"));\n      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n\n        return clone(propertyValues[indexInClass]);\n      }\n\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        assert$7(instanceIndex === batchId, \"Inherited property \\\"\".concat(name, \"\\\" is read-only.\"));\n\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n    return defined(result);\n  }\n\n}\n\nconst SIZEOF_UINT32$1 = 4;\nfunction parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {\n  const view = new DataView(arrayBuffer);\n  tile.magic = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32$1;\n  tile.version = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32$1;\n  tile.byteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32$1;\n\n  if (tile.version !== 1) {\n    throw new Error(\"3D Tile Version \".concat(tile.version, \" not supported\"));\n  }\n\n  return byteOffset;\n}\n\nconst SIZEOF_UINT32 = 4;\nconst DEPRECATION_WARNING = 'b3dm tile in legacy format.';\nfunction parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n  const view = new DataView(arrayBuffer);\n  let batchLength;\n  tile.header = tile.header || {};\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  if (batchTableJsonByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    console.warn(DEPRECATION_WARNING);\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    console.warn(DEPRECATION_WARNING);\n  }\n\n  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;\n  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;\n  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;\n  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;\n  tile.header.batchLength = batchLength;\n  return byteOffset;\n}\nfunction parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset);\n  return byteOffset;\n}\n\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n  const {\n    featureTableJsonByteLength,\n    featureTableBinaryByteLength,\n    batchLength\n  } = tile.header;\n  tile.featureTableJson = {\n    BATCH_LENGTH: batchLength || 0\n  };\n\n  if (featureTableJsonByteLength > 0) {\n    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);\n    tile.featureTableJson = JSON.parse(featureTableString);\n  }\n\n  byteOffset += featureTableJsonByteLength;\n  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n  return byteOffset;\n}\n\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n  const {\n    batchTableJsonByteLength,\n    batchTableBinaryByteLength\n  } = tile.header;\n\n  if (batchTableJsonByteLength > 0) {\n    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);\n    tile.batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  return byteOffset;\n}\n\nfunction normalize3DTileColorAttribute(tile, colors, batchTable) {\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {\n    batchIds,\n    isRGB565,\n    pointCount\n  } = tile;\n\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL$1.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL$1.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL$1.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  return {\n    type: GL$1.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}\n\nconst scratchNormal = new Vector3();\nfunction normalize3DTileNormalAttribute(tile, normals) {\n  if (!normals) {\n    return null;\n  }\n\n  if (tile.isOctEncoded16P) {\n    const decodedArray = new Float32Array(tile.pointsLength * 3);\n\n    for (let i = 0; i < tile.pointsLength; i++) {\n      octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal);\n      scratchNormal.toArray(decodedArray, i * 3);\n    }\n\n    return {\n      type: GL$1.FLOAT,\n      size: 2,\n      value: decodedArray\n    };\n  }\n\n  return {\n    type: GL$1.FLOAT,\n    size: 2,\n    value: normals\n  };\n}\n\nfunction normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n\n  return {\n    type: GL$1.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n\n  for (let i = 0; i < tile.pointCount; i++) {\n    scratchPosition.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i * 3);\n  }\n\n  return decodedArray;\n}\n\nasync function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset);\n  initializeTile(tile);\n  const {\n    featureTable,\n    batchTable\n  } = parsePointCloudTables(tile);\n  await parseDraco(tile, featureTable, batchTable, options, context);\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n\n  featureTable.featuresLength = pointsLength;\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL$1.FLOAT, 3);\n  const batchTable = parseBatchIds(tile, featureTable);\n  return {\n    featureTable,\n    batchTable\n  };\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL$1.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL$1.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL$1.FLOAT, 3);\n\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL$1.FLOAT, 3);\n\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL$1.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL$1.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL$1.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL$1.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL$1.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL$1.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable = null;\n\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL$1.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n\n      const {\n        batchTableJson,\n        batchTableBinary\n      } = tile;\n      batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n\n  return batchTable;\n}\n\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: { ...dracoFeatureTableProperties,\n      ...dracoBatchTableProperties\n    },\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n  return await loadDraco(tile, dracoData, options, context);\n}\n\nasync function loadDraco(tile, dracoData, options, context) {\n  const {\n    parse\n  } = context;\n  const dracoOptions = { ...options,\n    draco: { ...options.draco,\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  };\n  delete dracoOptions['3d-tiles'];\n  const data = await parse(dracoData.buffer, DracoLoader, dracoOptions);\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n\n  if (isQuantizedDraco) {\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  const batchTableAttributes = {};\n\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n\nconst VERSION$3 = \"3.1.4\" ;\n\nconst VERSION$2 = \"3.1.4\" ;\n\nconst VERSION$1 = \"3.1.4\" ;\nconst BASIS_CDN_ENCODER_WASM = \"https://unpkg.com/@loaders.gl/textures@\".concat(VERSION$1, \"/dist/libs/basis_encoder.wasm\");\nconst BASIS_CDN_ENCODER_JS = \"https://unpkg.com/@loaders.gl/textures@\".concat(VERSION$1, \"/dist/libs/basis_encoder.js\");\nlet loadBasisTranscoderPromise;\nasync function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.basis) {\n    return modules.basis;\n  }\n\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n  [BASIS, wasmBinary] = await Promise.all([await loadLibrary('basis_transcoder.js', 'textures', options), await loadLibrary('basis_transcoder.wasm', 'textures', options)]);\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise(resolve => {\n    BasisModule(options).then(module => {\n      const {\n        BasisFile,\n        initializeBasis\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile\n      });\n    });\n  });\n}\n\nlet loadBasisEncoderPromise;\nasync function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options), await loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)]);\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise(resolve => {\n    BasisEncoderModule(options).then(module => {\n      const {\n        BasisFile,\n        KTX2File,\n        initializeBasis,\n        BasisEncoder\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile,\n        KTX2File,\n        BasisEncoder\n      });\n    });\n  });\n}\n\nconst GL_EXTENSIONS_CONSTANTS = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n  COMPRESSED_SRGB8_ETC2: 0x9276,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n  COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\nconst WEBGL_EXTENSIONS = {\n  WEBGL_compressed_texture_s3tc: 'dxt',\n  WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n  WEBGL_compressed_texture_etc1: 'etc1',\n  WEBGL_compressed_texture_etc: 'etc2',\n  WEBGL_compressed_texture_pvrtc: 'pvrtc',\n  WEBGL_compressed_texture_atc: 'atc',\n  WEBGL_compressed_texture_astc: 'astc',\n  EXT_texture_compression_rgtc: 'rgtc'\n};\nlet formats = null;\nfunction getSupportedGPUTextureFormats(gl) {\n  if (!formats) {\n    gl = gl || getWebGLContext() || undefined;\n    formats = new Set();\n\n    for (const prefix of BROWSER_PREFIXES) {\n      for (const extension in WEBGL_EXTENSIONS) {\n        if (gl && gl.getExtension(\"\".concat(prefix).concat(extension))) {\n          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n          formats.add(gpuTextureFormat);\n        }\n      }\n    }\n  }\n\n  return formats;\n}\n\nfunction getWebGLContext() {\n  try {\n    const canvas = document.createElement('canvas');\n    return canvas.getContext('webgl');\n  } catch (error) {\n    return null;\n  }\n}\n\nvar n,i,s,a,r,o,l,f;!function(t){t[t.NONE=0]=\"NONE\",t[t.BASISLZ=1]=\"BASISLZ\",t[t.ZSTD=2]=\"ZSTD\",t[t.ZLIB=3]=\"ZLIB\";}(n||(n={})),function(t){t[t.BASICFORMAT=0]=\"BASICFORMAT\";}(i||(i={})),function(t){t[t.UNSPECIFIED=0]=\"UNSPECIFIED\",t[t.ETC1S=163]=\"ETC1S\",t[t.UASTC=166]=\"UASTC\";}(s||(s={})),function(t){t[t.UNSPECIFIED=0]=\"UNSPECIFIED\",t[t.SRGB=1]=\"SRGB\";}(a||(a={})),function(t){t[t.UNSPECIFIED=0]=\"UNSPECIFIED\",t[t.LINEAR=1]=\"LINEAR\",t[t.SRGB=2]=\"SRGB\",t[t.ITU=3]=\"ITU\",t[t.NTSC=4]=\"NTSC\",t[t.SLOG=5]=\"SLOG\",t[t.SLOG2=6]=\"SLOG2\";}(r||(r={})),function(t){t[t.ALPHA_STRAIGHT=0]=\"ALPHA_STRAIGHT\",t[t.ALPHA_PREMULTIPLIED=1]=\"ALPHA_PREMULTIPLIED\";}(o||(o={})),function(t){t[t.RGB=0]=\"RGB\",t[t.RRR=3]=\"RRR\",t[t.GGG=4]=\"GGG\",t[t.AAA=15]=\"AAA\";}(l||(l={})),function(t){t[t.RGB=0]=\"RGB\",t[t.RGBA=3]=\"RGBA\",t[t.RRR=4]=\"RRR\",t[t.RRRG=5]=\"RRRG\";}(f||(f={}));\n\nconst KTX2_ID = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\nfunction isKTX(data) {\n  const id = new Uint8Array(data);\n  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];\n  return !notKTX;\n}\n\nconst OutputFormat = {\n  etc1: {\n    basisFormat: 0,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: true\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: true\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: true\n  },\n  'bc7-m6-opaque-only': {\n    basisFormat: 6,\n    compressed: true\n  },\n  'bc7-m5': {\n    basisFormat: 7,\n    compressed: true\n  },\n  'pvrtc1-4-rgb': {\n    basisFormat: 8,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  'pvrtc1-4-rgba': {\n    basisFormat: 9,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  'astc-4x4': {\n    basisFormat: 10,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  'atc-rgb': {\n    basisFormat: 11,\n    compressed: true\n  },\n  'atc-rgba-interpolated-alpha': {\n    basisFormat: 12,\n    compressed: true\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: false\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: false\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: false\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: false\n  }\n};\nasync function parseBasis(data, options) {\n  if (options.basis.containerFormat === 'auto') {\n    if (isKTX(data)) {\n      const fileConstructors = await loadBasisEncoderModule(options);\n      return parseKTX2File(fileConstructors.KTX2File, data, options);\n    }\n\n    const {\n      BasisFile\n    } = await loadBasisTrascoderModule(options);\n    return parseBasisFile(BasisFile, data, options);\n  }\n\n  switch (options.basis.module) {\n    case 'encoder':\n      const fileConstructors = await loadBasisEncoderModule(options);\n\n      switch (options.basis.containerFormat) {\n        case 'ktx2':\n          return parseKTX2File(fileConstructors.KTX2File, data, options);\n\n        case 'basis':\n        default:\n          return parseBasisFile(fileConstructors.BasisFile, data, options);\n      }\n\n    case 'transcoder':\n    default:\n      const {\n        BasisFile\n      } = await loadBasisTrascoderModule(options);\n      return parseBasisFile(BasisFile, data, options);\n  }\n}\n\nfunction parseBasisFile(BasisFile, data, options) {\n  const basisFile = new BasisFile(new Uint8Array(data));\n\n  try {\n    if (!basisFile.startTranscoding()) {\n      return null;\n    }\n\n    const imageCount = basisFile.getNumImages();\n    const images = [];\n\n    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n      const levelsCount = basisFile.getNumLevels(imageIndex);\n      const levels = [];\n\n      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n      }\n\n      images.push(levels);\n    }\n\n    return images;\n  } finally {\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options) {\n  const width = basisFile.getImageWidth(imageIndex, levelIndex);\n  const height = basisFile.getImageHeight(imageIndex, levelIndex);\n  const hasAlpha = basisFile.getHasAlpha();\n  const {\n    compressed,\n    format,\n    basisFormat\n  } = getBasisOptions(options, hasAlpha);\n  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n    return null;\n  }\n\n  return {\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    hasAlpha,\n    format\n  };\n}\n\nfunction parseKTX2File(KTX2File, data, options) {\n  const ktx2File = new KTX2File(new Uint8Array(data));\n\n  try {\n    if (!ktx2File.startTranscoding()) {\n      return null;\n    }\n\n    const levelsCount = ktx2File.getLevels();\n    const levels = [];\n\n    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n      break;\n    }\n\n    return levels;\n  } finally {\n    ktx2File.close();\n    ktx2File.delete();\n  }\n}\n\nfunction transcodeKTX2Image(ktx2File, levelIndex, options) {\n  const {\n    alphaFlag,\n    height,\n    width\n  } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n  const {\n    compressed,\n    format,\n    basisFormat\n  } = getBasisOptions(options, alphaFlag);\n  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {\n    return null;\n  }\n\n  return {\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    alphaFlag,\n    format\n  };\n}\n\nfunction getBasisOptions(options, hasAlpha) {\n  let format = options && options.basis && options.basis.format;\n\n  if (format === 'auto') {\n    format = selectSupportedBasisFormat();\n  }\n\n  if (typeof format === 'object') {\n    format = hasAlpha ? format.alpha : format.noAlpha;\n  }\n\n  format = format.toLowerCase();\n  return OutputFormat[format];\n}\n\nfunction selectSupportedBasisFormat() {\n  const supportedFormats = getSupportedGPUTextureFormats();\n\n  if (supportedFormats.has('astc')) {\n    return 'astc-4x4';\n  } else if (supportedFormats.has('dxt')) {\n    return {\n      alpha: 'bc3',\n      noAlpha: 'bc1'\n    };\n  } else if (supportedFormats.has('pvrtc')) {\n    return {\n      alpha: 'pvrtc1-4-rgba',\n      noAlpha: 'pvrtc1-4-rgb'\n    };\n  } else if (supportedFormats.has('etc1')) {\n    return 'etc1';\n  } else if (supportedFormats.has('etc2')) {\n    return 'etc2';\n  }\n\n  return 'rgb565';\n}\n\nconst BasisWorkerLoader = {\n  name: 'Basis',\n  id: 'basis',\n  module: 'textures',\n  version: VERSION$2,\n  worker: true,\n  extensions: ['basis', 'ktx2'],\n  mimeTypes: ['application/octet-stream', 'image/ktx2'],\n  tests: ['sB'],\n  binary: true,\n  options: {\n    basis: {\n      format: 'auto',\n      libraryPath: 'libs/',\n      containerFormat: 'auto',\n      module: 'transcoder'\n    }\n  }\n};\nconst BasisLoader = { ...BasisWorkerLoader,\n  parse: parseBasis\n};\n\nconst VERSION = \"3.1.4\" ;\n\nconst {\n  _parseImageNode\n} = globalThis;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined';\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser$2 ? true : NODE_IMAGE_SUPPORTED;\nfunction isImageTypeSupported(type) {\n  switch (type) {\n    case 'auto':\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n\n    case 'image':\n      return IMAGE_SUPPORTED;\n\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(\"@loaders.gl/images: image \".concat(type, \" not supported in this environment\"));\n  }\n}\nfunction getDefaultImageType() {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n\nfunction getImageType(image) {\n  const format = getImageTypeOrNull(image);\n\n  if (!format) {\n    throw new Error('Not an image');\n  }\n\n  return format;\n}\nfunction getImageData(image) {\n  switch (getImageType(image)) {\n    case 'data':\n      return image;\n\n    case 'image':\n    case 'imagebitmap':\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n\n      if (!context) {\n        throw new Error('getImageData');\n      }\n\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n\n  return null;\n}\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nfunction isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nfunction getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error(error.message);\n    }\n\n    const src = \"data:image/svg+xml;base64,\".concat(btoa(xmlText));\n    return src;\n  }\n\n  return getBlob(arrayBuffer, url);\n}\nfunction getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n\n  return new Blob([new Uint8Array(arrayBuffer)]);\n}\n\nasync function parseToImage(arrayBuffer, options, url) {\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nasync function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n\n      image.onerror = err => reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\nasync function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  if (isSVG(url)) {\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error);\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n\n  return true;\n}\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\nfunction getBinaryImageMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);\n}\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n\n  if (!isPng) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n\n  if (!isGif) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\nfunction getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {\n    tableMarkers,\n    sofMarkers\n  } = getJpegMarkers();\n  let i = 2;\n\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN),\n        width: dataView.getUint16(i + 7, BIG_ENDIAN)\n      };\n    }\n\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);\n  return {\n    tableMarkers,\n    sofMarkers\n  };\n}\n\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n\n  throw new Error('toDataView');\n}\n\nasync function parseToNodeImage(arrayBuffer, options) {\n  const {\n    mimeType\n  } = getBinaryImageMetadata(arrayBuffer) || {};\n  const _parseImageNode = globalThis._parseImageNode;\n  assert$7(_parseImageNode);\n  return await _parseImageNode(arrayBuffer, mimeType);\n}\n\nasync function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n  const imageType = imageOptions.type || 'auto';\n  const {\n    url\n  } = context || {};\n  const loadType = getLoadableImageType(imageType);\n  let image;\n\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n\n    case 'data':\n      image = await parseToNodeImage(arrayBuffer);\n      break;\n\n    default:\n      assert$7(false);\n  }\n\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      return getDefaultImageType();\n\n    default:\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n\nconst EXTENSIONS$1 = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n  image: {\n    type: 'auto',\n    decode: true\n  }\n};\nconst ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS$1,\n  parse: parseImage,\n  tests: [arrayBuffer => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\n\nconst NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\nconst mimeTypeSupported = {};\nfunction _isImageFormatSupported(mimeType) {\n  if (mimeTypeSupported[mimeType] === undefined) {\n    mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);\n  }\n\n  return mimeTypeSupported[mimeType];\n}\n\nfunction checkFormatSupport(mimeType) {\n  switch (mimeType) {\n    case 'image/webp':\n      return checkWebPSupport();\n\n    case 'image/svg':\n      return isBrowser$2;\n\n    default:\n      if (!isBrowser$2) {\n        const {\n          _parseImageNode\n        } = globalThis;\n        return Boolean(_parseImageNode) && NODE_FORMAT_SUPPORT.includes(mimeType);\n      }\n\n      return true;\n  }\n}\n\nfunction checkWebPSupport() {\n  if (!isBrowser$2) {\n    return false;\n  }\n\n  try {\n    const element = document.createElement('canvas');\n    return element.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n  } catch {\n    return false;\n  }\n}\n\nfunction assert$1(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n\nfunction resolveUrl(url, options) {\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n\n  if (absolute) {\n    return url;\n  }\n\n  const baseUrl = options.baseUri || options.uri;\n\n  if (!baseUrl) {\n    throw new Error(\"'baseUri' must be provided to resolve relative url \".concat(url));\n  }\n\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n\nfunction getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert$1(bufferView);\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert$1(binChunk);\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];\nconst ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\nfunction getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n\n  return componentType;\n}\nfunction getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert$1(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {\n    ArrayType,\n    length,\n    byteLength\n  };\n}\n\nconst DEFAULT_GLTF_JSON = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\nclass GLTFScenegraph {\n  constructor(gltf) {\n    _defineProperty(this, \"gltf\", void 0);\n\n    _defineProperty(this, \"sourceBuffers\", void 0);\n\n    _defineProperty(this, \"byteLength\", void 0);\n\n    this.gltf = gltf || {\n      json: { ...DEFAULT_GLTF_JSON\n      },\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  get json() {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key) {\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key) {\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index) {\n    return this.getObject('scenes', index);\n  }\n\n  getNode(index) {\n    return this.getObject('nodes', index);\n  }\n\n  getSkin(index) {\n    return this.getObject('skins', index);\n  }\n\n  getMesh(index) {\n    return this.getObject('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this.getObject('materials', index);\n  }\n\n  getAccessor(index) {\n    return this.getObject('accessors', index);\n  }\n\n  getTexture(index) {\n    return this.getObject('textures', index);\n  }\n\n  getSampler(index) {\n    return this.getObject('samplers', index);\n  }\n\n  getImage(index) {\n    return this.getObject('images', index);\n  }\n\n  getBufferView(index) {\n    return this.getObject('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this.getObject('buffers', index);\n  }\n\n  getObject(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n\n    const object = this.json[array] && this.json[array][index];\n\n    if (!object) {\n      throw new Error(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  getTypedArrayForBufferView(bufferView) {\n    bufferView = this.getBufferView(bufferView);\n    const bufferIndex = bufferView.buffer;\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert$1(binChunk);\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  getTypedArrayForAccessor(accessor) {\n    accessor = this.getAccessor(accessor);\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n    const {\n      ArrayType,\n      length\n    } = getAccessorArrayTypeAndLength(accessor, bufferView);\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  getTypedArrayForImageData(image) {\n    image = this.getAccessor(image);\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  addApplicationData(key, data) {\n    this.json[key] = data;\n    return this;\n  }\n\n  addExtraData(key, data) {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object, extensionName, data) {\n    object.extensions = object.extensions || {};\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object, extensionName, data) {\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n  }\n\n  removeObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  addExtension(extensionName, extensionData = {}) {\n    assert$1(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  addRequiredExtension(extensionName, extensionData = {}) {\n    assert$1(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  registerUsedExtension(extensionName) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n\n    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  registerRequiredExtension(extensionName) {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n\n    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  removeExtension(extensionName) {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  setDefaultScene(sceneIndex) {\n    this.json.scene = sceneIndex;\n  }\n\n  addScene(scene) {\n    const {\n      nodeIndices\n    } = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({\n      nodes: nodeIndices\n    });\n    return this.json.scenes.length - 1;\n  }\n\n  addNode(node) {\n    const {\n      meshIndex,\n      matrix\n    } = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {\n      mesh: meshIndex\n    };\n\n    if (matrix) {\n      nodeData.matrix = matrix;\n    }\n\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  addMesh(mesh) {\n    const {\n      attributes,\n      indices,\n      material,\n      mode = 4\n    } = mesh;\n\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessors,\n        mode\n      }]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes) {\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessorIndices,\n        mode: 0\n      }]\n    };\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addImage(imageData, mimeTypeOpt) {\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);\n    const bufferViewIndex = this.addBufferView(imageData);\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  addBufferView(buffer) {\n    const byteLength = buffer.byteLength;\n    assert$1(Number.isFinite(byteLength));\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n    const glTFBufferView = {\n      buffer: 0,\n      byteOffset: this.byteLength,\n      byteLength\n    };\n    this.byteLength += padToNBytes(byteLength, 4);\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  addAccessor(bufferViewIndex, accessor) {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      type: getAccessorTypeFromSize(accessor.size),\n      componentType: accessor.componentType,\n      count: accessor.count,\n      max: accessor.max,\n      min: accessor.min\n    };\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  addBinaryBuffer(sourceBuffer, accessor = {\n    size: 3\n  }) {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    let minMax = {\n      min: accessor.min,\n      max: accessor.max\n    };\n\n    if (!minMax.min || !minMax.max) {\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  addTexture(texture) {\n    const {\n      imageIndex\n    } = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  addMaterial(pbrMaterialInfo) {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  createBinaryChunk() {\n    var _this$json, _this$json$buffers;\n\n    this.gltf.buffers = [];\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n    let dstByteOffset = 0;\n\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{\n        byteLength: totalByteLength\n      }];\n    }\n\n    this.gltf.binary = arrayBuffer;\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n\n    while (found) {\n      const index = array.indexOf(string);\n\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  _addAttributes(attributes = {}) {\n    const result = {};\n\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n\n      const attrName = this._getGltfAttributeName(attributeKey);\n\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n\n    return result;\n  }\n\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {\n      size: 1\n    });\n  }\n\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n\n      default:\n        return attributeName;\n    }\n  }\n\n  _getAccessorMinMax(buffer, size) {\n    const result = {\n      min: null,\n      max: null\n    };\n\n    if (buffer.length < size) {\n      return result;\n    }\n\n    result.min = [];\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n\n    for (const value of initValues) {\n      result.min.push(value);\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);\n        result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);\n      }\n    }\n\n    return result;\n  }\n\n}\n\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\nconst wasm_base = 'B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB';\nconst wasm_simd = 'B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB';\nconst detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);\nconst wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);\nconst FILTERS = {\n  0: '',\n  1: 'meshopt_decodeFilterOct',\n  2: 'meshopt_decodeFilterQuat',\n  3: 'meshopt_decodeFilterExp',\n  NONE: '',\n  OCTAHEDRAL: 'meshopt_decodeFilterOct',\n  QUATERNION: 'meshopt_decodeFilterQuat',\n  EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\nconst DECODERS = {\n  0: 'meshopt_decodeVertexBuffer',\n  1: 'meshopt_decodeIndexBuffer',\n  2: 'meshopt_decodeIndexSequence',\n  ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n  TRIANGLES: 'meshopt_decodeIndexBuffer',\n  INDICES: 'meshopt_decodeIndexSequence'\n};\nfunction isMeshoptSupported() {\n  return isWebAssemblySupported;\n}\nasync function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = 'NONE') {\n  const instance = await loadWasmInstance();\n  decode$5(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || 'NONE']]);\n}\nlet wasmPromise;\n\nasync function loadWasmInstance() {\n  if (!wasmPromise) {\n    wasmPromise = loadWasmModule();\n  }\n\n  return wasmPromise;\n}\n\nasync function loadWasmModule() {\n  let wasm = wasm_base;\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n\n  const result = await WebAssembly.instantiate(unpack(wasm), {});\n  await result.instance.exports.__wasm_call_ctors();\n  return result.instance;\n}\n\nfunction unpack(data) {\n  const result = new Uint8Array(data.length);\n\n  for (let i = 0; i < data.length; ++i) {\n    const ch = data.charCodeAt(i);\n    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n  }\n\n  let write = 0;\n\n  for (let i = 0; i < data.length; ++i) {\n    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n  }\n\n  return result.buffer.slice(0, write);\n}\n\nfunction decode$5(instance, fun, target, count, size, source, filter) {\n  const sbrk = instance.exports.sbrk;\n  const count4 = count + 3 & ~3;\n  const tp = sbrk(count4 * size);\n  const sp = sbrk(source.length);\n  const heap = new Uint8Array(instance.exports.memory.buffer);\n  heap.set(source, sp);\n  const res = fun(tp, count, size, sp, source.length);\n\n  if (res === 0 && filter) {\n    filter(tp, count4, size);\n  }\n\n  target.set(heap.subarray(tp, tp + count * size));\n  sbrk(tp - sbrk(0));\n\n  if (res !== 0) {\n    throw new Error(\"Malformed buffer data: \".concat(res));\n  }\n}\n\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nconst name$6 = EXT_MESHOPT_COMPRESSION;\nfunction preprocess$4(gltfData) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) && !isMeshoptSupported()) {\n    throw new Error(\"gltf: Required extension \".concat(EXT_MESHOPT_COMPRESSION, \" not supported by browser\"));\n  }\n}\nasync function decode$4(gltfData, options) {\n  var _options$gltf;\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const promises = [];\n\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n\nvar EXT_meshopt_compression = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$6,\n    preprocess: preprocess$4,\n    decode: decode$4\n});\n\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\nconst name$5 = EXT_TEXTURE_WEBP;\nfunction preprocess$3(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!_isImageFormatSupported('image/webp')) {\n    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n      throw new Error(\"gltf: Required extension \".concat(EXT_TEXTURE_WEBP, \" not supported by browser\"));\n    }\n\n    return;\n  }\n\n  const {\n    json\n  } = scenegraph;\n\n  for (const texture of json.textures || []) {\n    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);\n\n    if (extension) {\n      texture.source = extension.source;\n    }\n\n    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n  }\n\n  scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n\nvar EXT_texture_webp = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$5,\n    preprocess: preprocess$3\n});\n\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\nconst name$4 = KHR_TEXTURE_BASISU;\nfunction preprocess$2(gltfData, options) {\n  const scene = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = scene;\n\n  for (const texture of json.textures || []) {\n    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);\n\n    if (extension) {\n      texture.source = extension.source;\n    }\n\n    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n  }\n\n  scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n\nvar KHR_texture_basisu = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$4,\n    preprocess: preprocess$2\n});\n\nfunction getGLTFAccessors(attributes) {\n  const accessors = {};\n\n  for (const name in attributes) {\n    const attribute = attributes[name];\n\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n\n  return accessors;\n}\nfunction getGLTFAccessor(attribute) {\n  const {\n    buffer,\n    size,\n    count\n  } = getAccessorData(attribute);\n  const glTFAccessor = {\n    value: buffer,\n    size,\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n  return glTFAccessor;\n}\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n\n    count = buffer.length / size;\n  }\n\n  return {\n    buffer,\n    size,\n    count\n  };\n}\n\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n\n  return array;\n}\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nconst name$3 = KHR_DRACO_MESH_COMPRESSION;\nfunction preprocess$1(gltfData, options, context) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) ;\n  }\n}\nasync function decode$3(gltfData, options, context) {\n  var _options$gltf;\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nfunction encode$3(gltfData, options = {}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    compressMesh(mesh);\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);\n  const {\n    parse\n  } = context;\n  const dracoOptions = { ...options\n  };\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n\n      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  primitive.attributes = decodedAttributes;\n\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  checkPrimitive(primitive);\n}\n\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n  var _context$parseSync;\n\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {\n    attributes\n  });\n\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode,\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors\n        }\n      }\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n\nvar KHR_draco_mesh_compression = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$3,\n    preprocess: preprocess$1,\n    decode: decode$3,\n    encode: encode$3\n});\n\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nconst name$2 = KHR_LIGHTS_PUNCTUAL;\nasync function decode$2(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n\n  if (extension) {\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n\n    if (nodeExtension) {\n      node.light = nodeExtension.light;\n    }\n\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\nasync function encode$2(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    assert$1(!extension.lights);\n    extension.lights = json.lights;\n    delete json.lights;\n  }\n\n  if (gltfScenegraph.json.lights) {\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n\n    delete gltfScenegraph.json.lights;\n  }\n}\n\nvar KHR_lights_punctual = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$2,\n    decode: decode$2,\n    encode: encode$2\n});\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nconst name$1 = KHR_MATERIALS_UNLIT;\nasync function decode$1(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n\n    if (extension) {\n      material.unlit = true;\n    }\n\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\nfunction encode$1(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      if (material.unlit) {\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n\nvar KHR_materials_unlit = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$1,\n    decode: decode$1,\n    encode: encode$1\n});\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nconst name = KHR_TECHNIQUES_WEBGL;\nasync function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n\n      if (materialExtension) {\n        material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\nasync function encode(gltfData, options) {}\n\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}\n\nvar KHR_techniques_webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name,\n    decode: decode,\n    encode: encode\n});\n\nconst EXTENSIONS = [EXT_meshopt_compression, EXT_texture_webp, KHR_texture_basisu, KHR_draco_mesh_compression, KHR_lights_punctual, KHR_materials_unlit, KHR_techniques_webgl];\nfunction preprocessExtensions(gltf, options = {}, context) {\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n\n  for (const extension of extensions) {\n    var _extension$preprocess;\n\n    (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);\n  }\n}\nasync function decodeExtensions(gltf, options = {}, context) {\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n\n  for (const extension of extensions) {\n    var _extension$decode;\n\n    await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));\n  }\n}\n\nfunction useExtension(extensionName, options) {\n  var _options$gltf;\n\n  const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\nfunction preprocess(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  for (const image of json.images || []) {\n    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);\n\n    if (extension) {\n      Object.assign(image, extension);\n    }\n\n    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n  }\n\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\nclass GLTFV1Normalizer {\n  constructor() {\n    _defineProperty(this, \"idToIndexMap\", {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    });\n\n    _defineProperty(this, \"json\", void 0);\n  }\n\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    switch (json.asset && json.asset.version) {\n      case '2.0':\n        return;\n\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        console.warn(\"glTF: Unknown version \".concat(json.asset.version));\n        return;\n    }\n\n    if (!options.normalize) {\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    this._convertTopLevelObjectsToArrays(json);\n\n    preprocess(gltf);\n\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    json[mapName] = [];\n\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id;\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {\n        attributes,\n        indices,\n        material\n      } = primitive;\n\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));\n    }\n\n    if (node.meshes) {\n      node.meshes = node.meshes.map(mesh => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(\"gltf v1: json doesn't contain attribute \".concat(topLevelArrayName));\n      json[topLevelArrayName] = [];\n    }\n\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n\n        const index = this._convertIdToIndex(id, key);\n\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n\n      if (!Number.isFinite(index)) {\n        throw new Error(\"gltf v1: failed to resolve \".concat(key, \" with id \").concat(id));\n      }\n\n      return index;\n    }\n\n    return id;\n  }\n\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      delete buffer.type;\n    }\n  }\n\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex(texture => texture.id === textureId);\n\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {\n          index: textureIndex\n        };\n      }\n    }\n  }\n\n}\n\nfunction normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nconst GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  constructor() {\n    _defineProperty(this, \"baseUri\", '');\n\n    _defineProperty(this, \"json\", {});\n\n    _defineProperty(this, \"buffers\", []);\n\n    _defineProperty(this, \"images\", []);\n  }\n\n  postProcess(gltf, options = {}) {\n    const {\n      json,\n      buffers = [],\n      images = [],\n      baseUri = ''\n    } = gltf;\n    assert$1(json);\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null;\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n\n    const object = this.json[array] && this.json[array][index];\n\n    if (!object) {\n      console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  _resolveScene(scene, index) {\n    scene.id = scene.id || \"scene-\".concat(index);\n    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    node.id = node.id || \"node-\".concat(index);\n\n    if (node.children) {\n      node.children = node.children.map(child => this.getNode(child));\n    }\n\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce((accum, meshIndex) => {\n        const mesh = this.getMesh(meshIndex);\n        accum.id = mesh.id;\n        accum.primitives = accum.primitives.concat(mesh.primitives);\n        return accum;\n      }, {\n        primitives: []\n      });\n    }\n\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    skin.id = skin.id || \"skin-\".concat(index);\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    mesh.id = mesh.id || \"mesh-\".concat(index);\n\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map(primitive => {\n        primitive = { ...primitive\n        };\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n\n        return primitive;\n      });\n    }\n\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    material.id = material.id || \"material-\".concat(index);\n\n    if (material.normalTexture) {\n      material.normalTexture = { ...material.normalTexture\n      };\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n\n    if (material.occlusionTexture) {\n      material.occlustionTexture = { ...material.occlustionTexture\n      };\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = { ...material.emmisiveTexture\n      };\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness\n      };\n      const mr = material.pbrMetallicRoughness;\n\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = { ...mr.baseColorTexture\n        };\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture\n        };\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    accessor.id = accessor.id || \"accessor-\".concat(index);\n\n    if (accessor.bufferView !== undefined) {\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {\n        ArrayType,\n        byteLength\n      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n      }\n\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n    }\n\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    texture.id = texture.id || \"texture-\".concat(index);\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    sampler.id = sampler.id || \"sampler-\".concat(index);\n    sampler.parameters = {};\n\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    image.id = image.id || \"image-\".concat(index);\n\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    const preloadedImage = this.images[index];\n\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    const bufferIndex = bufferView.buffer;\n    const result = {\n      id: \"bufferView-\".concat(index),\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || \"camera-\".concat(index);\n\n    if (camera.perspective) ;\n\n    if (camera.orthographic) ;\n\n    return camera;\n  }\n\n}\n\nfunction postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\nconst LE = true;\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nfunction isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  const {\n    magic = MAGIC_glTF\n  } = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nfunction parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE);\n  const byteLength = dataView.getUint32(byteOffset + 8, LE);\n  Object.assign(glb, {\n    header: {\n      byteOffset,\n      byteLength,\n      hasBinChunk: false\n    },\n    type,\n    version,\n    json: {},\n    binChunks: []\n  });\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset);\n\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n\n    default:\n      throw new Error(\"Invalid GLB version \".concat(glb.version, \". Only supports v1 and v2.\"));\n  }\n}\n\nfunction parseGLBV1(glb, dataView, byteOffset) {\n  assert$7(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  const contentLength = dataView.getUint32(byteOffset + 0, LE);\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE);\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n  assert$7(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n  return byteOffset;\n}\n\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  assert$7(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n\n        break;\n\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n  glb.json = JSON.parse(jsonText);\n  return padToNBytes(chunkLength, 4);\n}\n\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n  return padToNBytes(chunkLength, 4);\n}\n\nasync function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n  var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;\n\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n  normalizeGLTFV1(gltf, {\n    normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize\n  });\n  preprocessExtensions(gltf, options, context);\n  const promises = [];\n\n  if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n  await Promise.all(promises);\n  return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert$1(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert$1(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {\n      binChunks\n    } = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nasync function loadBuffers(gltf, options, context) {\n  const buffers = gltf.json.buffers || [];\n\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n\n    if (buffer.uri) {\n      var _context$fetch, _response$arrayBuffer;\n\n      const {\n        fetch\n      } = context;\n      assert$1(fetch);\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));\n      const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const imageIndices = getReferencesImageIndices(gltf);\n  const images = gltf.json.images || [];\n  const promises = [];\n\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\nfunction getReferencesImageIndices(gltf) {\n  const imageIndices = new Set();\n  const textures = gltf.json.textures || [];\n\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\nasync function loadImage(gltf, image, index, options, context) {\n  const {\n    fetch,\n    parse\n  } = context;\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert$1(arrayBuffer, 'glTF image has no data');\n  let parsedImage = await parse(arrayBuffer, [ImageLoader, BasisLoader], {\n    mimeType: image.mimeType,\n    basis: options.basis || {\n      format: selectSupportedBasisFormat()\n    }\n  }, context);\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage\n    };\n  }\n\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n\nconst GLTFLoader = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION$3,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse: parse$1,\n  options: {\n    gltf: {\n      normalize: true,\n      loadBuffers: true,\n      loadImages: true,\n      decompressMeshes: true,\n      postProcess: true\n    },\n    log: console\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\nasync function parse$1(arrayBuffer, options = {}, context) {\n  options = { ...GLTFLoader.options,\n    ...options\n  };\n  options.gltf = { ...GLTFLoader.options.gltf,\n    ...options.gltf\n  };\n  const {\n    byteOffset = 0\n  } = options;\n  const gltf = {};\n  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n\nconst GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\nfunction parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n  tile.rotateYtoZ = true;\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  tile.gltfUpAxis = options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis ? options['3d-tiles'].assetGltfUpAxis : 'Y';\n  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) ; else {\n    console.warn(\"\".concat(tile.type, \": embedded glb is not aligned to a 4-byte boundary.\"));\n  }\n\n  return tile.byteOffset + tile.byteLength;\n}\nasync function extractGLTF(tile, gltfFormat, options, context) {\n  const tile3DOptions = options['3d-tiles'] || {};\n  extractGLTFBufferOrURL(tile, gltfFormat);\n\n  if (tile3DOptions.loadGLTF) {\n    const {\n      parse,\n      fetch\n    } = context;\n\n    if (tile.gltfUrl) {\n      tile.gltfArrayBuffer = await fetch(tile.gltfUrl, options);\n      tile.gltfByteOffset = 0;\n    }\n\n    if (tile.gltfArrayBuffer) {\n      tile.gltf = await parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      const textDecoder = new TextDecoder();\n      const gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n\n    default:\n      throw new Error('b3dm: Illegal glTF format field');\n  }\n}\n\nasync function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  var _tile$gltf;\n\n  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options);\n  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);\n  const extensions = tile === null || tile === void 0 ? void 0 : (_tile$gltf = tile.gltf) === null || _tile$gltf === void 0 ? void 0 : _tile$gltf.extensions;\n\n  if (extensions && extensions.CESIUM_RTC) {\n    tile.rtcCenter = extensions.CESIUM_RTC.center;\n  }\n\n  return byteOffset;\n}\n\nfunction parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL$1.FLOAT, 3);\n  return byteOffset;\n}\n\nasync function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n\n  if (tile.version !== 1) {\n    throw new Error(\"Instanced 3D Model version \".concat(tile.version, \" is not supported\"));\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  const view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL$1.FLOAT, 3);\n  const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\n\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false,\n    url: undefined,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    forwardAxis: [1, 0, 0]\n  };\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  new Vector3();\n  new Vector3();\n  new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL$1.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL$1.UNSIGNED_SHORT, 3, i, instancePosition);\n      const quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL$1.FLOAT, 3, scratchVector1);\n\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL$1.FLOAT, 3, scratchVector2);\n\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n\n      for (let j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL$1.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL$1.FLOAT, 3, i, scratch2);\n\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL$1.UNSIGNED_SHORT, 2, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL$1.UNSIGNED_SHORT, 2, scratch2);\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL$1.FLOAT, 1, i);\n\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL$1.FLOAT, 3, i, scratch1);\n\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    instanceTranslationRotationScale.scale = instanceScale;\n    let batchId = featureTable.getProperty('BATCH_ID', GL$1.UNSIGNED_SHORT, 1, i);\n\n    if (batchId === undefined) {\n      batchId = i;\n    }\n\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}\n\nasync function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  const view = new DataView(arrayBuffer);\n  tile.tilesLength = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  tile.tiles = [];\n\n  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {\n    const subtile = {};\n    tile.tiles.push(subtile);\n    byteOffset = await parse3DTile(arrayBuffer, byteOffset, options, context, subtile);\n  }\n\n  return byteOffset;\n}\n\nasync function parseGltf3DTile(tile, arrayBuffer, options, context) {\n  tile.rotateYtoZ = true;\n  tile.gltfUpAxis = options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis ? options['3d-tiles'].assetGltfUpAxis : 'Y';\n  const {\n    parse\n  } = context;\n  tile.gltf = await parse(arrayBuffer, GLTFLoader, options, context);\n}\n\nasync function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = {}) {\n  tile.byteOffset = byteOffset;\n  tile.type = getMagicString$1(arrayBuffer, byteOffset);\n\n  switch (tile.type) {\n    case TILE3D_TYPE.COMPOSITE:\n      return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);\n\n    case TILE3D_TYPE.BATCHED_3D_MODEL:\n      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    case TILE3D_TYPE.GLTF:\n      return await parseGltf3DTile(tile, arrayBuffer, options, context);\n\n    case TILE3D_TYPE.INSTANCED_3D_MODEL:\n      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    case TILE3D_TYPE.POINT_CLOUD:\n      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    default:\n      throw new Error(\"3DTileLoader: unknown type \".concat(tile.type));\n  }\n}\n\nconst SUBTREE_FILE_MAGIC = 0x74627573;\nconst SUBTREE_FILE_VERSION = 1;\nasync function parse3DTilesSubtree(data) {\n  const magic = new Uint32Array(data.slice(0, 4));\n\n  if (magic[0] !== SUBTREE_FILE_MAGIC) {\n    throw new Error('Wrong subtree file magic number');\n  }\n\n  const version = new Uint32Array(data.slice(4, 8));\n\n  if (version[0] !== SUBTREE_FILE_VERSION) {\n    throw new Error('Wrong subtree file verson, must be 1');\n  }\n\n  const jsonByteLength = parseUint64Value(data.slice(8, 16));\n  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);\n  const textDecoder = new TextDecoder('utf8');\n  const string = textDecoder.decode(stringAttribute);\n  const subtree = JSON.parse(string);\n  const binaryByteLength = parseUint64Value(data.slice(16, 24));\n  let internalBinaryBuffer = new ArrayBuffer(0);\n\n  if (binaryByteLength) {\n    internalBinaryBuffer = data.slice(24 + jsonByteLength);\n  }\n\n  if ('bufferView' in subtree.tileAvailability) {\n    subtree.tileAvailability.explicitBitstream = await getExplicitBitstream(subtree, 'tileAvailability', internalBinaryBuffer);\n  }\n\n  if ('bufferView' in subtree.contentAvailability) {\n    subtree.contentAvailability.explicitBitstream = await getExplicitBitstream(subtree, 'contentAvailability', internalBinaryBuffer);\n  }\n\n  if ('bufferView' in subtree.childSubtreeAvailability) {\n    subtree.childSubtreeAvailability.explicitBitstream = await getExplicitBitstream(subtree, 'childSubtreeAvailability', internalBinaryBuffer);\n  }\n\n  return subtree;\n}\n\nasync function getExplicitBitstream(subtree, name, internalBinaryBuffer) {\n  const bufferViewIndex = subtree[name].bufferView;\n  const bufferView = subtree.bufferViews[bufferViewIndex];\n  const buffer = subtree.buffers[bufferView.buffer];\n\n  if (buffer.uri) {\n    const response = await fetchFile(buffer.uri);\n    const data = await response.arrayBuffer();\n    return new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);\n  }\n\n  return new Uint8Array(internalBinaryBuffer, bufferView.byteOffset, bufferView.byteLength);\n}\n\nfunction parseUint64Value(buffer) {\n  const dataView = new DataView(buffer);\n  const left = dataView.getUint32(0, true);\n  const right = dataView.getUint32(4, true);\n  return left + 2 ** 32 * right;\n}\n\nconst Tile3DSubtreeLoader = {\n  id: '3d-tiles-subtree',\n  name: '3D Tiles Subtree',\n  module: '3d-tiles',\n  version: VERSION$5,\n  extensions: ['subtree'],\n  mimeTypes: ['application/octet-stream'],\n  tests: ['subtree'],\n  parse: parse3DTilesSubtree,\n  options: {}\n};\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\nasync function parseImplicitTiles(subtree, options, parentData = {\n  mortonIndex: 0,\n  x: 0,\n  y: 0,\n  z: 0\n}, childIndex = 0, level = 0, globalData = {\n  level: 0,\n  mortonIndex: 0,\n  x: 0,\n  y: 0,\n  z: 0\n}) {\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n  const tile = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: ''\n  };\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n  const childX = childIndex & 0b01;\n  const childY = childIndex >> 1 & 0b01;\n  const childZ = childIndex >> 2 & 0b01;\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = \"\".concat(basePath, \"/\").concat(subtreesUriTemplate);\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n    subtree = childSubtree;\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {\n    mortonIndex: childTileMortonIndex,\n    x: childTileX,\n    y: childTileY,\n    z: childTileZ\n  };\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(subtree, options, pData, index, childTileLevel, globalData);\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {\n        childTileX,\n        childTileY,\n        childTileZ\n      };\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData, index) {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\nfunction formatTileData(tile, level, childCoordinates, options) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(\"\".concat(basePath, \"/\"), '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    boundingVolume\n  };\n}\n\nfunction calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {\n  if (rootBoundingVolume.region) {\n    const {\n      childTileX,\n      childTileY,\n      childTileZ\n    } = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\nfunction concatBits(first, second) {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\nfunction replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  const mapUrl = generateMapUrl({\n    level,\n    x,\n    y,\n    z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, matched => mapUrl[matched]);\n}\n\nfunction generateMapUrl(items) {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[\"{\".concat(key, \"}\")] = items[key];\n  }\n\n  return mapUrl;\n}\n\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n\n    default:\n      return refine;\n  }\n}\n\nfunction normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = \"\".concat(options.basePath, \"/\").concat(contentUri);\n  }\n\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\nfunction normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n  const stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {\n        basePath\n      });\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\nasync function normalizeImplicitTileHeaders(tileset) {\n  if (!tileset.root) {\n    return null;\n  }\n\n  const basePath = tileset.basePath;\n  const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {\n      uri: subtreesUriTemplate\n    }\n  } = implicitTilingExtension;\n  const subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const rootSubtreeUrl = \"\".concat(basePath, \"/\").concat(subtreeUrl);\n  const rootSubtree = await load(rootSubtreeUrl, Tile3DSubtreeLoader);\n  const contentUrlTemplate = \"\".concat(basePath, \"/\").concat(tileset.root.content.uri);\n  const refine = tileset.root.refine;\n  const rootLodMetricValue = tileset.root.geometricError;\n  const rootBoundingVolume = tileset.root.boundingVolume;\n  const options = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n  return await normalizeImplicitTileData(tileset.root, rootSubtree, options);\n}\nasync function normalizeImplicitTileData(tile, rootSubtree, options) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  const {\n    children,\n    contentUrl\n  } = await parseImplicitTiles(rootSubtree, options);\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {\n      uri: contentUrl.replace(\"\".concat(options.basePath, \"/\"), '')\n    };\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n  return tile;\n}\n\nconst IMPLICIT_TILING_EXTENSION_NAME = '3DTILES_implicit_tiling';\nconst Tiles3DLoader = {\n  id: '3d-tiles',\n  name: '3D Tiles',\n  module: '3d-tiles',\n  version: VERSION$5,\n  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  mimeTypes: ['application/octet-stream'],\n  tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  parse,\n  options: {\n    '3d-tiles': {\n      loadGLTF: true,\n      decodeQuantizedPositions: false,\n      isTileset: 'auto',\n      assetGltfUpAxis: null\n    }\n  }\n};\n\nfunction getBaseUri(tileset) {\n  return dirname(tileset.url);\n}\n\nasync function parseTile(arrayBuffer, options, context) {\n  const tile = {\n    content: {\n      featureIds: null\n    }\n  };\n  const byteOffset = 0;\n  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);\n  return tile.content;\n}\n\nasync function parseTileset(data, options, context) {\n  var _tilesetJson$root;\n\n  const tilesetJson = JSON.parse(new TextDecoder().decode(data));\n  tilesetJson.loader = options.loader || Tiles3DLoader;\n  tilesetJson.url = context.url;\n  tilesetJson.basePath = getBaseUri(tilesetJson);\n  tilesetJson.root = hasImplicitTilingExtension(tilesetJson) ? await normalizeImplicitTileHeaders(tilesetJson) : normalizeTileHeaders(tilesetJson);\n  tilesetJson.type = TILESET_TYPE.TILES3D;\n  tilesetJson.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tilesetJson.lodMetricValue = ((_tilesetJson$root = tilesetJson.root) === null || _tilesetJson$root === void 0 ? void 0 : _tilesetJson$root.lodMetricValue) || 0;\n  return tilesetJson;\n}\n\nasync function parse(data, options, context) {\n  const loaderOptions = options['3d-tiles'] || {};\n  let isTileset;\n\n  if (loaderOptions.isTileset === 'auto') {\n    isTileset = context.url && context.url.indexOf('.json') !== -1;\n  } else {\n    isTileset = loaderOptions.isTileset;\n  }\n\n  if (isTileset) {\n    data = await parseTileset(data, options, context);\n  } else {\n    data = await parseTile(data, options, context);\n  }\n\n  return data;\n}\n\nfunction hasImplicitTilingExtension(tilesetJson) {\n  var _tilesetJson$extensio, _tilesetJson$extensio2;\n\n  return (tilesetJson === null || tilesetJson === void 0 ? void 0 : (_tilesetJson$extensio = tilesetJson.extensionsRequired) === null || _tilesetJson$extensio === void 0 ? void 0 : _tilesetJson$extensio.includes(IMPLICIT_TILING_EXTENSION_NAME)) && (tilesetJson === null || tilesetJson === void 0 ? void 0 : (_tilesetJson$extensio2 = tilesetJson.extensionsUsed) === null || _tilesetJson$extensio2 === void 0 ? void 0 : _tilesetJson$extensio2.includes(IMPLICIT_TILING_EXTENSION_NAME));\n}\n\nconst CESIUM_ION_URL = 'https://api.cesium.com/v1/assets';\nasync function getIonTilesetMetadata(accessToken, assetId) {\n  if (!assetId) {\n    const assets = await getIonAssets(accessToken);\n\n    for (const item of assets.items) {\n      if (item.type === '3DTILES') {\n        assetId = item.id;\n      }\n    }\n  }\n\n  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);\n  const {\n    type,\n    url\n  } = ionAssetMetadata;\n  assert$7(type === '3DTILES' && url);\n  ionAssetMetadata.headers = {\n    Authorization: \"Bearer \".concat(ionAssetMetadata.accessToken)\n  };\n  return ionAssetMetadata;\n}\nasync function getIonAssets(accessToken) {\n  assert$7(accessToken);\n  const url = CESIUM_ION_URL;\n  const headers = {\n    Authorization: \"Bearer \".concat(accessToken)\n  };\n  const response = await fetchFile(url, {\n    fetch: {\n      headers\n    }\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n}\nasync function getIonAssetMetadata(accessToken, assetId) {\n  assert$7(accessToken, assetId);\n  const headers = {\n    Authorization: \"Bearer \".concat(accessToken)\n  };\n  const url = \"\".concat(CESIUM_ION_URL, \"/\").concat(assetId);\n  let response = await fetchFile(\"\".concat(url), {\n    fetch: {\n      headers\n    }\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  let metadata = await response.json();\n  response = await fetchFile(\"\".concat(url, \"/endpoint\"), {\n    fetch: {\n      headers\n    }\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  const tilesetInfo = await response.json();\n  metadata = { ...metadata,\n    ...tilesetInfo\n  };\n  return metadata;\n}\n\nasync function preload(url, options = {}) {\n  options = options['cesium-ion'] || {};\n  const {\n    accessToken\n  } = options;\n  let assetId = options.assetId;\n\n  if (!Number.isFinite(assetId)) {\n    const matched = url.match(/\\/([0-9]+)\\/tileset.json/);\n    assetId = matched && matched[1];\n  }\n\n  return getIonTilesetMetadata(accessToken, assetId);\n}\n\nconst CesiumIonLoader = { ...Tiles3DLoader,\n  id: 'cesium-ion',\n  name: 'Cesium Ion',\n  preload,\n  parse: async (data, options, context) => {\n    options = { ...options\n    };\n    options['3d-tiles'] = options['cesium-ion'];\n    options.loader = CesiumIonLoader;\n    return Tiles3DLoader.parse(data, options, context);\n  },\n  options: {\n    'cesium-ion': { ...Tiles3DLoader.options['3d-tiles'],\n      accessToken: null\n    }\n  }\n};\n\n// From https://github.com/potree/potree/blob/master/src/materials/PointCloudMaterial.js\r\nfunction generateGradientTexture(gradient) {\r\n    const size = 64;\r\n    // create canvas\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = size;\r\n    canvas.height = size;\r\n    // get context\r\n    const context = canvas.getContext('2d');\r\n    // draw gradient\r\n    context.rect(0, 0, size, size);\r\n    const ctxGradient = context.createLinearGradient(0, 0, size, size);\r\n    for (let i = 0; i < gradient.length; i++) {\r\n        const step = gradient[i];\r\n        ctxGradient.addColorStop(step[0], '#' + step[1].getHexString());\r\n    }\r\n    context.fillStyle = ctxGradient;\r\n    context.fill();\r\n    //let texture = new THREE.Texture(canvas);\r\n    const texture = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(canvas);\r\n    texture.needsUpdate = true;\r\n    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\r\n    texture.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\r\n    texture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\r\n    texture.repeat.set(2, 2);\r\n    // textureImage = texture.image;\r\n    return texture;\r\n}\r\nfunction getCameraFrustum(camera) {\r\n    camera.updateMatrix(); // make sure camera's local matrix is updated\r\n    camera.updateMatrixWorld(); // make sure camera's world matrix is updated\r\n    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\r\n    const frustum = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\r\n    frustum.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\r\n    return frustum;\r\n}\r\nfunction loadersPlaneToMesh(plane) {\r\n    const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\r\n    // Create a basic rectangle geometry from math.gl plane\r\n    const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5);\r\n    // Align the geometry to the plane\r\n    const coplanarPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...plane.projectPointOntoPlane([0, 0, 0]));\r\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(plane.normal.x, plane.normal.y, plane.normal.z);\r\n    const focalPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(coplanarPoint).add(normal);\r\n    planeGeometry.lookAt(focalPoint);\r\n    planeGeometry.translate(coplanarPoint.x, coplanarPoint.y, coplanarPoint.z);\r\n    // Edges\r\n    /*\r\n    const edges = new EdgesGeometry(planeGeometry)\r\n    var dispPlane = new LineSegments(edges, new LineBasicMaterial({ color: 0x00ffff }))*/\r\n    //plane\r\n    const material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 0x00ffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide });\r\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(planeGeometry, material);\r\n    const arrowHelper = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(normal, coplanarPoint, 5, 0xffff00);\r\n    group.add(arrowHelper);\r\n    group.add(mesh);\r\n    return group;\r\n}\r\nfunction loadersBoundingBoxToMesh(tile) {\r\n    // Create a basic rectangle geometry from math.gl half-axes\r\n    const { boundingVolume } = tile;\r\n    let redColor = 0;\r\n    if (tile.content) {\r\n        redColor = Math.min(tile.content.byteLength / 500000, 1.0);\r\n    }\r\n    const boxColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(redColor, 1.0, 0.0);\r\n    const boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1);\r\n    const boxTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\r\n    if (boundingVolume.halfAxes) {\r\n        boxTransform.copy(getMatrix4FromHalfAxes(boundingVolume.halfAxes));\r\n    }\r\n    else if (boundingVolume.radius) {\r\n        boxGeometry.scale(boundingVolume.radius * 2, boundingVolume.radius * 2, boundingVolume.radius * 2);\r\n    }\r\n    boxGeometry.applyMatrix4(boxTransform);\r\n    const edges = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(boxGeometry);\r\n    const dispPlane = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(edges, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({ color: boxColor }));\r\n    dispPlane.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...boundingVolume.center));\r\n    return dispPlane;\r\n}\r\nfunction getMatrix4FromHalfAxes(halfAxes) {\r\n    const m = halfAxes;\r\n    const rotateMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([\r\n        m[0] * 2,\r\n        m[1] * 2,\r\n        m[2] * 2,\r\n        0,\r\n        m[3] * 2,\r\n        m[4] * 2,\r\n        m[5] * 2,\r\n        0,\r\n        m[6] * 2,\r\n        m[7] * 2,\r\n        m[8] * 2,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n    ]);\r\n    return rotateMatrix;\r\n}\n\nconst Gradients = {\r\n    // From chroma spectral http://gka.github.io/chroma.js/\r\n    SPECTRAL: [\r\n        [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)],\r\n        [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)],\r\n        [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)],\r\n        [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 0.749)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)],\r\n        [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)],\r\n        [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)],\r\n        [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 0.0039, 0.2588)],\r\n    ],\r\n    PLASMA: [\r\n        [0.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)],\r\n        [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 0.001, 0.654)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)],\r\n        [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)],\r\n        [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)],\r\n        [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)],\r\n        [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)],\r\n        [1.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)],\r\n    ],\r\n    YELLOW_GREEN: [\r\n        [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)],\r\n        [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)],\r\n        [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.5099, 0.5319)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.5881, 0.5569)],\r\n        [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)],\r\n        [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)],\r\n        [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)],\r\n        [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)],\r\n    ],\r\n    VIRIDIS: [\r\n        [0.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.005, 0.329)],\r\n        [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)],\r\n        [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)],\r\n        [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)],\r\n        [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)],\r\n        [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)],\r\n        [1.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)],\r\n    ],\r\n    INFERNO: [\r\n        [0.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)],\r\n        [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)],\r\n        [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)],\r\n        [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)],\r\n        [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)],\r\n        [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)],\r\n        [1.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)],\r\n    ],\r\n    GRAYSCALE: [\r\n        [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\r\n        [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\r\n    ],\r\n    // 16 samples of the TURBU color scheme\r\n    // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\r\n    // original file licensed under Apache-2.0\r\n    TURBO: [\r\n        [0.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)],\r\n        [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)],\r\n        [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)],\r\n        [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)],\r\n        [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)],\r\n        [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)],\r\n        [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)],\r\n        [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)],\r\n        [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)],\r\n        [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)],\r\n        [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)],\r\n        [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)],\r\n        [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)],\r\n        [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)],\r\n        [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)],\r\n        [1.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 0.00424)],\r\n    ],\r\n    RAINBOW: [\r\n        [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)],\r\n        [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)],\r\n        [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)],\r\n        [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)],\r\n        [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)],\r\n        [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)],\r\n        [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)],\r\n    ],\r\n    CONTOUR: [\r\n        [0.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\r\n        [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\r\n        [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\r\n        [1.0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\r\n    ],\r\n};\n\nconst MeshFS = `\n  uniform sampler2D map;\n  varying vec2 vUv;\n\n  void main() {\n    vec4 realColor = texture2D(map, vUv);\n    gl_FragColor = realColor;\n  }\n`;\r\nconst MeshVS = `\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\r\nconst PointCloudFS = `\n  varying vec3 vColor;\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, 1.0 );\n    }\n  }\n`;\r\nconst PointCloudVS = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = 1.0;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\n\n/** Types of coloring used when viewing point cloud tiles */\r\nvar PointCloudColoring;\r\n(function (PointCloudColoring) {\r\n    PointCloudColoring[PointCloudColoring[\"Intensity\"] = 1] = \"Intensity\";\r\n    PointCloudColoring[PointCloudColoring[\"Classification\"] = 2] = \"Classification\";\r\n    PointCloudColoring[PointCloudColoring[\"Elevation\"] = 3] = \"Elevation\";\r\n    PointCloudColoring[PointCloudColoring[\"RGB\"] = 4] = \"RGB\";\r\n    PointCloudColoring[PointCloudColoring[\"White\"] = 5] = \"White\";\r\n})(PointCloudColoring || (PointCloudColoring = {}));\r\n/** Types of shading used when viewing b3dm (mesh) tiles */\r\nvar Shading;\r\n(function (Shading) {\r\n    Shading[Shading[\"FlatTexture\"] = 1] = \"FlatTexture\";\r\n    Shading[Shading[\"ShadedTexture\"] = 2] = \"ShadedTexture\";\r\n    Shading[Shading[\"ShadedNoTexture\"] = 3] = \"ShadedNoTexture\";\r\n})(Shading || (Shading = {}));\n\nconst gradient = Gradients.RAINBOW;\r\nconst gradientTexture = typeof document != 'undefined' ? generateGradientTexture(gradient) : null;\r\nconst grayscale = Gradients.GRAYSCALE;\r\nconst grayscaleTexture = typeof document != 'undefined' ? generateGradientTexture(grayscale) : null;\r\nconst defaultOptions = {\r\n    throttleRequests: true,\r\n    maxRequests: 64,\r\n    updateInterval: 0.1,\r\n    maxConcurrency: 1,\r\n    maximumScreenSpaceError: 16,\r\n    maximumMemoryUsage: 32,\r\n    viewDistanceScale: 1.0,\r\n    skipLevelOfDetail: false,\r\n    updateTransforms: true,\r\n    shading: Shading.FlatTexture,\r\n    pointCloudColoring: PointCloudColoring.White,\r\n    worker: true,\r\n    wireframe: false,\r\n    debug: false,\r\n    basisTranscoderPath: null,\r\n    dracoDecoderPath: null,\r\n    material: null,\r\n    computeNormals: false,\r\n    shaderCallback: null\r\n};\r\n/** 3D Tiles Loader */\r\nclass Loader3DTiles {\r\n    /**\r\n    * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\r\n    * @public\r\n    *\r\n    * @param props - Properties for this load call {@link LoaderProps}.\r\n    * @returns An object containing the 3D Model to be added to the scene\r\n    * and a runtime engine to be updated every frame.\r\n    */\r\n    static load(props) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const options = Object.assign(Object.assign({}, defaultOptions), props.options);\r\n            const { url } = props;\r\n            const UPDATE_INTERVAL = options.updateInterval;\r\n            const loadersGLOptions = {};\r\n            if (options.cesiumIONToken) {\r\n                loadersGLOptions['cesium-ion'] = {\r\n                    accessToken: options.cesiumIONToken,\r\n                };\r\n                const metadata = yield CesiumIonLoader.preload(url, loadersGLOptions);\r\n                loadersGLOptions['fetch'] = { headers: metadata.headers };\r\n            }\r\n            const tilesetJson = yield load(url, Tiles3DLoader, Object.assign({}, loadersGLOptions));\r\n            const renderMap = {};\r\n            const boxMap = {};\r\n            const unloadQueue = [];\r\n            const root = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\r\n            const tileBoxes = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\r\n            if (!options.debug) {\r\n                tileBoxes.visible = false;\r\n            }\r\n            const pointcloudUniforms = {\r\n                pointSize: { type: 'f', value: 1.0 },\r\n                gradient: { type: 't', value: gradientTexture },\r\n                grayscale: { type: 't', value: grayscaleTexture },\r\n                rootCenter: { type: 'vec3', value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\r\n                rootNormal: { type: 'vec3', value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\r\n                coloring: { type: 'i', value: options.pointCloudColoring },\r\n                hideGround: { type: 'b', value: true },\r\n                elevationRange: { type: 'vec2', value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400) },\r\n                maxIntensity: { type: 'f', value: 1.0 },\r\n                intensityContrast: { type: 'f', value: 1.0 },\r\n            };\r\n            let cameraReference = null;\r\n            let rendererReference = null;\r\n            const gltfLoader = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader();\r\n            if (options.basisTranscoderPath) {\r\n                const ktx2Loader = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader();\r\n                ktx2Loader.detectSupport(props.renderer);\r\n                ktx2Loader.setTranscoderPath(options.basisTranscoderPath + '/');\r\n                ktx2Loader.setWorkerLimit(1);\r\n                gltfLoader.setKTX2Loader(ktx2Loader);\r\n            }\r\n            if (options.dracoDecoderPath) {\r\n                const dracoLoader = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader();\r\n                dracoLoader.setDecoderPath(options.dracoDecoderPath + '/');\r\n                dracoLoader.setWorkerLimit(options.maxConcurrency);\r\n                gltfLoader.setDRACOLoader(dracoLoader);\r\n            }\r\n            const unlitMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\r\n                uniforms: {},\r\n                vertexShader: MeshVS,\r\n                fragmentShader: MeshFS,\r\n            });\r\n            const tileOptions = {\r\n                maximumMemoryUsage: options.maximumMemoryUsage,\r\n                maximumScreenSpaceError: options.maximumScreenSpaceError,\r\n                viewDistanceScale: options.viewDistanceScale,\r\n                skipLevelOfDetail: options.skipLevelOfDetail,\r\n                updateTransforms: options.updateTransforms,\r\n                throttleRequests: options.throttleRequests,\r\n                maxRequests: options.maxRequests,\r\n                contentLoader: (tile) => __awaiter(this, void 0, void 0, function* () {\r\n                    let tileContent = null;\r\n                    switch (tile.type) {\r\n                        case TILE_TYPE.POINTCLOUD: {\r\n                            tileContent = createPointNodes(tile, pointcloudUniforms);\r\n                            break;\r\n                        }\r\n                        case TILE_TYPE.SCENEGRAPH:\r\n                        case TILE_TYPE.MESH: {\r\n                            tileContent = yield createGLTFNodes(gltfLoader, tile, unlitMaterial, options, rootTransformInverse);\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (tileContent) {\r\n                        tileContent.visible = false;\r\n                        renderMap[tile.id] = tileContent;\r\n                        root.add(renderMap[tile.id]);\r\n                        if (options.debug) {\r\n                            const box = loadersBoundingBoxToMesh(tile);\r\n                            tileBoxes.add(box);\r\n                            boxMap[tile.id] = box;\r\n                        }\r\n                    }\r\n                }),\r\n                onTileLoad: () => __awaiter(this, void 0, void 0, function* () {\r\n                    if (tileset) {\r\n                        tileset._frameNumber++;\r\n                        tilesetUpdate(tileset, renderMap, rendererReference, cameraReference);\r\n                    }\r\n                }),\r\n                onTileUnload: (tile) => {\r\n                    unloadQueue.push(tile);\r\n                },\r\n                onTileError: (tile, message) => {\r\n                    console.error('Tile error', tile.id, message);\r\n                },\r\n            };\r\n            const tileset = new Tileset3D(tilesetJson, Object.assign(Object.assign({}, tileOptions), { loadOptions: Object.assign(Object.assign({}, loadersGLOptions), { maxConcurrency: options.maxConcurrency, worker: options.worker, gltf: {\r\n                        loadImages: false,\r\n                    }, '3d-tiles': {\r\n                        loadGLTF: false\r\n                    } }) }));\r\n            //\r\n            // transformations\r\n            let threeMat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\r\n            const tileTrasnform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\r\n            if (tileset.root.transform) {\r\n                tileTrasnform.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(tileset.root.transform));\r\n            }\r\n            if (tileset.root.children.length == 1 && tileset.root.children[0].transform) {\r\n                const childTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(tileset.root.children[0].transform);\r\n                tileTrasnform.multiply(childTransform);\r\n            }\r\n            if (tileTrasnform.equals(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().identity()) && tileset.root.header.boundingVolume) {\r\n                if (tileset.root.header.boundingVolume.region) {\r\n                    // TODO: Handle region type bounding volumes\r\n                    console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\");\r\n                }\r\n                else {\r\n                    tileTrasnform.setPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...tileset.root.boundingVolume.center));\r\n                }\r\n            }\r\n            // TODO: Originally the tileset is moved by loaders.gl to its WGS84 matching coordiate. In here, we negate that and bring it back to 0,0,0 with an optional initial transform. If we want to combine the tileset with other geographic layers we might need to go back to those original coordiates\r\n            threeMat.copy(tileTrasnform).invert();\r\n            const resetTransform = threeMat.clone();\r\n            let modelMatrix = new Matrix4(threeMat.toArray());\r\n            tileset.modelMatrix = modelMatrix;\r\n            let disposeFlag = false;\r\n            const rootCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\r\n            pointcloudUniforms.rootCenter.value.copy(rootCenter);\r\n            pointcloudUniforms.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize());\r\n            // Extra stats\r\n            tileset.stats.get('Loader concurrency').count = options.maxConcurrency;\r\n            tileset.stats.get('Maximum SSE').count = options.maximumScreenSpaceError;\r\n            tileset.stats.get('Maximum mem usage').count = options.maximumMemoryUsage;\r\n            let timer = 0;\r\n            const lastCameraTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(Infinity, Infinity, Infinity);\r\n            let lastCameraAspect = null;\r\n            const lastCameraPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Infinity, Infinity, Infinity);\r\n            let sseDenominator = null;\r\n            const lastRootTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(root.matrixWorld);\r\n            const rootTransformInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(lastRootTransform).invert();\r\n            function tilesetUpdate(tileset, renderMap, renderer, camera) {\r\n                if (disposeFlag) {\r\n                    return;\r\n                }\r\n                // Assumes camera fov, near and far are not changing\r\n                if (!sseDenominator || camera.aspect != lastCameraAspect) {\r\n                    const loadersFrustum = new PerspectiveFrustum({\r\n                        fov: (camera.fov / 180) * Math.PI,\r\n                        aspectRatio: camera.aspect,\r\n                        near: camera.near,\r\n                        far: camera.far,\r\n                    });\r\n                    sseDenominator = loadersFrustum.sseDenominator;\r\n                    lastCameraAspect = camera.aspect;\r\n                    if (options.debug) {\r\n                        console.log('Updated sse denonimator:', sseDenominator);\r\n                    }\r\n                }\r\n                const frustum = getCameraFrustum(camera);\r\n                const planes = frustum.planes.map((plane) => new Plane(plane.normal.toArray(), plane.constant));\r\n                const cullingVolume = new CullingVolume(planes);\r\n                const rendererSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n                renderer.getSize(rendererSize);\r\n                const frameState = {\r\n                    camera: {\r\n                        position: lastCameraPosition.toArray(),\r\n                    },\r\n                    height: rendererSize.y,\r\n                    frameNumber: tileset._frameNumber,\r\n                    sseDenominator: sseDenominator,\r\n                    cullingVolume: cullingVolume,\r\n                    viewport: {\r\n                        id: 0,\r\n                    },\r\n                };\r\n                tileset._cache.reset();\r\n                tileset._traverser.traverse(tileset.root, frameState, tileset.options);\r\n                for (const tile of tileset.tiles) {\r\n                    if (tile.selected) {\r\n                        if (!renderMap[tile.id]) {\r\n                            console.error('TILE SELECTED BUT NOT LOADED!!', tile.id);\r\n                        }\r\n                        else {\r\n                            // Make sure it's visible\r\n                            renderMap[tile.id].visible = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (renderMap[tile.id]) {\r\n                            renderMap[tile.id].visible = false;\r\n                        }\r\n                    }\r\n                }\r\n                while (unloadQueue.length > 0) {\r\n                    const tile = unloadQueue.pop();\r\n                    if (renderMap[tile.id] && tile.contentState == TILE_CONTENT_STATE.UNLOADED) {\r\n                        root.remove(renderMap[tile.id]);\r\n                        disposeNode(renderMap[tile.id]);\r\n                        delete renderMap[tile.id];\r\n                    }\r\n                    if (boxMap[tile.id]) {\r\n                        disposeNode(boxMap[tile.id]);\r\n                        tileBoxes.remove(boxMap[tile.id]);\r\n                        delete boxMap[tile.id];\r\n                    }\r\n                }\r\n                if (props.onProgress) {\r\n                    props.onProgress(tileset.stats.get('Tiles Loaded').count, tileset.stats.get('Tiles Loaded').count + tileset.stats.get('Tiles Loading').count);\r\n                }\r\n                return frameState;\r\n            }\r\n            return {\r\n                model: root,\r\n                runtime: {\r\n                    getTileset: () => {\r\n                        return tileset;\r\n                    },\r\n                    getStats: () => {\r\n                        return tileset.stats;\r\n                    },\r\n                    showTiles: (visible) => {\r\n                        tileBoxes.visible = visible;\r\n                    },\r\n                    setWireframe: (wireframe) => {\r\n                        options.wireframe = wireframe;\r\n                        root.traverse((object) => {\r\n                            if (object instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\r\n                                object.material.wireframe = wireframe;\r\n                            }\r\n                        });\r\n                    },\r\n                    setDebug: (debug) => {\r\n                        options.debug = debug;\r\n                        tileBoxes.visible = debug;\r\n                    },\r\n                    setShading: (shading) => {\r\n                        options.shading = shading;\r\n                    },\r\n                    getTileBoxes: () => {\r\n                        return tileBoxes;\r\n                    },\r\n                    setViewDistanceScale: (scale) => {\r\n                        tileset.options.viewDistanceScale = scale;\r\n                        tileset._frameNumber++;\r\n                        tilesetUpdate(tileset, renderMap, rendererReference, cameraReference);\r\n                    },\r\n                    setHideGround: (enabled) => {\r\n                        pointcloudUniforms.hideGround.value = enabled;\r\n                    },\r\n                    setPointCloudColoring: (selection) => {\r\n                        pointcloudUniforms.coloring.value = selection;\r\n                    },\r\n                    setElevationRange: (range) => {\r\n                        pointcloudUniforms.elevationRange.value.set(range[0], range[1]);\r\n                    },\r\n                    setMaxIntensity: (intensity) => {\r\n                        pointcloudUniforms.maxIntensity.value = intensity;\r\n                    },\r\n                    setIntensityContrast: (contrast) => {\r\n                        pointcloudUniforms.intensityContrast.value = contrast;\r\n                    },\r\n                    getLatLongHeightFromPosition: (position) => {\r\n                        const cartographicPosition = tileset.ellipsoid.cartesianToCartographic(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(position).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(threeMat).invert()).toArray());\r\n                        return {\r\n                            lat: cartographicPosition[1],\r\n                            long: cartographicPosition[0],\r\n                            height: cartographicPosition[2],\r\n                        };\r\n                    },\r\n                    getPositionFromLatLongHeight: (coord) => {\r\n                        const cartesianPosition = tileset.ellipsoid.cartographicToCartesian([coord.long, coord.lat, coord.height]);\r\n                        return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...cartesianPosition).applyMatrix4(threeMat);\r\n                    },\r\n                    getCameraFrustum: (camera) => {\r\n                        const frustum = getCameraFrustum(camera);\r\n                        const meshes = frustum.planes\r\n                            .map((plane) => new Plane(plane.normal.toArray(), plane.constant))\r\n                            .map((loadersPlane) => loadersPlaneToMesh(loadersPlane));\r\n                        const model = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\r\n                        for (const mesh of meshes)\r\n                            model.add(mesh);\r\n                        return model;\r\n                    },\r\n                    update: function (dt, renderer, camera) {\r\n                        cameraReference = camera;\r\n                        rendererReference = renderer;\r\n                        timer += dt;\r\n                        if (tileset && timer >= UPDATE_INTERVAL) {\r\n                            if (!lastRootTransform.equals(root.matrixWorld)) {\r\n                                lastRootTransform.copy(root.matrixWorld);\r\n                                threeMat = resetTransform.clone();\r\n                                threeMat.premultiply(lastRootTransform);\r\n                                const rootCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(lastRootTransform);\r\n                                pointcloudUniforms.rootCenter.value.copy(rootCenter);\r\n                                pointcloudUniforms.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(lastRootTransform).normalize());\r\n                                rootTransformInverse.copy(lastRootTransform).invert();\r\n                                modelMatrix = new Matrix4(threeMat.toArray());\r\n                                tileset.modelMatrix = modelMatrix;\r\n                            }\r\n                            const cameraChanged = !camera.matrixWorld.equals(lastCameraTransform) ||\r\n                                !(camera.aspect == lastCameraAspect);\r\n                            if (cameraChanged) {\r\n                                timer = 0;\r\n                                tileset._frameNumber++;\r\n                                camera.getWorldPosition(lastCameraPosition);\r\n                                lastCameraTransform.copy(camera.matrixWorld);\r\n                                tilesetUpdate(tileset, renderMap, renderer, camera);\r\n                            }\r\n                        }\r\n                    },\r\n                    dispose: function () {\r\n                        disposeFlag = true;\r\n                        tileset._destroy();\r\n                        while (root.children.length > 0) {\r\n                            const obj = root.children[0];\r\n                            disposeNode(obj);\r\n                            root.remove(obj);\r\n                        }\r\n                        while (tileBoxes.children.length > 0) {\r\n                            const obj = tileBoxes.children[0];\r\n                            tileBoxes.remove(obj);\r\n                            obj.geometry.dispose();\r\n                            obj.material.dispose();\r\n                        }\r\n                    },\r\n                },\r\n            };\r\n        });\r\n    }\r\n}\r\nfunction createGLTFNodes(gltfLoader, tile, unlitMaterial, options, rootTransformInverse) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        return new Promise((resolve, reject) => {\r\n            var _a;\r\n            const rotateX = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2);\r\n            const shouldRotate = ((_a = tile.tileset.asset) === null || _a === void 0 ? void 0 : _a.gltfUpAxis) !== \"Z\";\r\n            // The computed trasnform already contains the root's transform, so we have to invert it\r\n            const contentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(tile.computedTransform).premultiply(rootTransformInverse);\r\n            if (shouldRotate) {\r\n                contentTransform.multiply(rotateX); // convert from GLTF Y-up to Z-up\r\n            }\r\n            gltfLoader.parse(tile.content.gltfArrayBuffer, tile.contentUrl ? tile.contentUrl.substr(0, tile.contentUrl.lastIndexOf('/') + 1) : '', (gltf) => {\r\n                const tileContent = gltf.scenes[0];\r\n                tileContent.applyMatrix4(contentTransform);\r\n                tileContent.traverse((object) => {\r\n                    if (object instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\r\n                        const originalMaterial = object.material;\r\n                        const originalMap = originalMaterial.map;\r\n                        if (options.material) {\r\n                            object.material = options.material.clone();\r\n                            originalMaterial.dispose();\r\n                        }\r\n                        else if (options.shading == Shading.FlatTexture) {\r\n                            object.material = unlitMaterial.clone();\r\n                            originalMaterial.dispose();\r\n                        }\r\n                        if (options.shading != Shading.ShadedNoTexture) {\r\n                            if (object.material.uniforms) {\r\n                                object.material.uniforms.map = { value: originalMap };\r\n                            }\r\n                            else {\r\n                                object.material.map = originalMap;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (originalMap) {\r\n                                originalMap.dispose();\r\n                            }\r\n                            object.material.map = null;\r\n                        }\r\n                        if (options.shaderCallback) {\r\n                            object.onBeforeRender = options.shaderCallback;\r\n                        }\r\n                        object.material.wireframe = options.wireframe;\r\n                        if (options.computeNormals) {\r\n                            object.geometry.computeVertexNormals();\r\n                        }\r\n                    }\r\n                });\r\n                resolve(tileContent);\r\n            }, (e) => {\r\n                reject(new Error(`error parsing gltf in tile ${tile.id}: ${e}`));\r\n            });\r\n        });\r\n    });\r\n}\r\nfunction createPointNodes(tile, pointcloudUniforms) {\r\n    const d = {\r\n        rtc_center: tile.content.rtcCenter,\r\n        points: tile.content.attributes.positions,\r\n        intensities: tile.content.attributes.intensity,\r\n        classifications: tile.content.attributes.classification,\r\n        rgb: null,\r\n        rgba: null,\r\n    };\r\n    const { colors } = tile.content.attributes;\r\n    if (colors && colors.size === 3) {\r\n        d.rgb = colors.value;\r\n    }\r\n    if (colors && colors.size === 4) {\r\n        d.rgba = colors.value;\r\n    }\r\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\r\n    geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(d.points, 3));\r\n    const pointcloudMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\r\n        uniforms: pointcloudUniforms,\r\n        vertexShader: PointCloudVS,\r\n        fragmentShader: PointCloudFS,\r\n        transparent: true,\r\n    });\r\n    if (d.rgba) {\r\n        geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(d.rgba, 4));\r\n        pointcloudMaterial.vertexColors = true;\r\n    }\r\n    else if (d.rgb) {\r\n        geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(d.rgb, 3, true));\r\n        pointcloudMaterial.vertexColors = true;\r\n    }\r\n    if (d.intensities) {\r\n        geometry.setAttribute('intensity', new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(d.intensities, 1, true));\r\n    }\r\n    if (d.classifications) {\r\n        geometry.setAttribute('classification', new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(d.classifications, 1, false));\r\n    }\r\n    const tileContent = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, pointcloudMaterial);\r\n    if (d.rtc_center) {\r\n        const c = d.rtc_center;\r\n        // TODO: In the case of entwine/region bounding volume the modelMatrix also needs to be applied?\r\n        tileContent.applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(c[0], c[1], c[2])); //.multiply(threeMat));\r\n    }\r\n    return tileContent;\r\n}\r\nfunction disposeMaterial(material) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    if ((_b = (_a = material) === null || _a === void 0 ? void 0 : _a.uniforms) === null || _b === void 0 ? void 0 : _b.map) {\r\n        (_e = (_d = (_c = material) === null || _c === void 0 ? void 0 : _c.uniforms) === null || _d === void 0 ? void 0 : _d.map.value) === null || _e === void 0 ? void 0 : _e.dispose();\r\n    }\r\n    else if (material.map) {\r\n        (_f = material.map) === null || _f === void 0 ? void 0 : _f.dispose();\r\n    }\r\n    material.dispose();\r\n}\r\nfunction disposeNode(node) {\r\n    node.traverse((object) => {\r\n        if (object.isMesh) {\r\n            object.geometry.dispose();\r\n            if (object.material.isMaterial) {\r\n                disposeMaterial(object.material);\r\n            }\r\n            else {\r\n                // an array of materials\r\n                for (const material of object.material) {\r\n                    disposeMaterial(material);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    for (let i = node.children.length - 1; i >= 0; i--) {\r\n        const obj = node.children[i];\r\n        node.remove(obj);\r\n    }\r\n}\n\n\n//# sourceMappingURL=three-loader-3dtiles.esm.js.map\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./node_modules/three-loader-3dtiles/dist/three-loader-3dtiles.esm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});